<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  <!-- , user-scalable=no -->
    <title>Digital Image Processing Editor</title>
    <meta content="Apply elementary machine operatives to image rasters" name="description"/>
    <meta content="Greg Sidal" name="author"/>

<!--    <link rel="stylesheet" type="text/css" href="../ui2.css">  -->
    <style>
/*------ general ------*/
  body {border: 0; margin: 0; padding: 0;}
  body {font-family:'Arial','Helvetica Neue','Helvetica',sans-serif; font-size: 0.90em; background-color: #ccc; color: #444;}
  body.app {position: fixed; left: 0; top: 0; right: 0; bottom: 0;}
  /*@media all and (max-width:500px) and (orientation:portrait) {
    body {font-size: 1.0em;}
  }*/
  div {position: relative; margin:0; padding:0;}
  .pin {position: absolute;}
  .pin.corner {}
  .pin.corner.left {left: 0;}
  .pin.corner.top {top: 0;}
  .pin.corner.right {right: 0;}
  .pin.corner.bottom {bottom: 0;}


/*------ app frame (canvas/image on backing) ------*/
  .snap, .resp-back, .responsive {
    position: absolute; border: 0; margin: 0; padding: 0; left: 0; top: 0; right: 0; bottom: 0;
    touch-action: none; /*pan-x pan-y;*/
  }

  /* back with bar */
  .snap, .resp-back  {background-color: transparent; overflow: hidden;}
  .resp-back.bargap {}
  .resp-back.bargap.top {top: 2.5em; border-top: 1px solid #eee;}
  .resp-back.bargap.bottom {bottom: 2.5em; border-bottom: 1px solid #eee;}

  /* image/canvas */
  .responsive {position: relative; display: block; background-color: #fff;}
  /* shrink/stretch wid or hgt, preserve aspect */
  .responsive.resp-resize {left: 50%; top: 50%; transform-origin: center; transform: translate(-50%, -50%);}
  .responsive.resp-resize {width: auto; max-width: 100%; height: auto; max-height: 100%;}
  @media all and (orientation:portrait) {
    .responsive.resp-resize {left: 50%; top: 0; transform: translate(-50%, 0);}
  }

  /* manip mode */
  .responsive.resp-manip {transition: transform 0.7s ease;}
  .responsive.resp-manip {cursor: grab; user-select: none;}
  .responsive.resp-manip.manip-panning {cursor: grabbing;}
  .responsive.resp-manip.manip-zooming-in {cursor: zoom-in;}
  .responsive.resp-manip.manip-zooming-out {cursor: zoom-out;}
  @media (hover: hover) {
    .responsive.resp-manip.manip-zooming-in {transition: transform 1.1s ease;}
    .responsive.resp-manip.manip-zooming-out {transition: transform 1.1s ease;}
  }
  .responsive.resp-manip.manip-panning {transition: none;}

  @media (hover: hover) {
    .resp-back {scrollbar-width: thin; scrollbar-color: #bbb auto;}
    .resp-back::-webkit-scrollbar {width: 7px; height: 7px;}
    .resp-back::-webkit-scrollbar-track {background: rgba(220,220,220,0.5);}
    .resp-back::-webkit-scrollbar-thumb {background-color: #999; border-radius: 10px; border: 4px solid transparent;}
    .resp-back::-webkit-scrollbar-thumb:hover {background-color: #777;}
  }


/*------ toolbar ------*/
  .bar {
    display: block; margin: 0; padding: 0; position: absolute; left: 0; right: 0; height: 2.5em;
  }
  .bar.top {top: 0;}
  .bar.bottom {bottom: 0;}
  .bar.dark {background-color: #c0c0c4;}

  .toolbar {
    display: block; margin: auto 0.3em; padding: 0.15em 0;
    background-color: transparent; text-align: center; white-space: nowrap; overflow-x: auto;
  }
  .toolbar > .btnbar {font-size: 130%;}
  .toolbar > .text {font-size: 80%; vertical-align: 0.10em;}
  .toolbar > .text.middle {margin-left: 0.6em; margin-right: 0.5em;}
  .toolbar > .text.clickable {margin-left: 0.4em;}
  .toolbar > .text:empty {margin: 0;}
  @media all and (orientation:landscape) {
    .toolbar {text-align: right;}
    .toolbar {overflow-x: hidden;}
  }

  /*print toolbar tiny*/
  @media print {
    .resp-back.bargap.top {top: 0.9em;}
    .resp-back.bargap.bottom {bottom: 0.9em;}
    .bar {height: 0.9em;}
    .toolbar {font-size:70%; margin: 0;}
    .toolbar > .btnbar {display: none; font-size: 0.1em;}
  }


/*------ panels ------*/
  .panelwrap {display: block; padding:0;}
  .panelwrap.page {position: relative; width: 50em; max-width: 100%; margin:0 auto;}
  .panelwrap.popup {position: static; margin:0;}
  @media all and (orientation:portrait) {
    .panelwrap.popup, .panelwrap.page {width: 100%;}
  }
  .panel {
    display: block; background-color: transparent;
    opacity: 1.0; visibility: visible; transition: opacity 0.4s ease, visibility 0.4s ease;
  }
  .panel.popup {
    position: absolute; top: 0; left: 0; overflow-y: auto;  min-width: 22em; max-height: 100%;
    border-right: 1px solid #bbb; border-bottom: 1px solid #bbb;
  }
  .panel.page {position: relative; height: auto; border: 0;}
  .panel.visible {}
  .panel.hidden {opacity: 0.0; visibility: hidden;}
  @media all and (orientation:portrait) {
    .panel {width: 100%;}
    .panel.popup {min-width: auto; max-height: 60%; bottom: 0; top: auto; border: 0; border-top: 1px solid #ccc;}
    .panel.popup.maxheight {max-height: 85%;}
    .panel.popup.fullheight {max-height: 100%;}
    .panel.popup.pintop {bottom: auto; top: 0; border-top: 0; border-bottom: 1px solid #ccc;}
  }
  /*print without popup panels*/
  @media print {
    .panel.popup {display: none;}
  }


/*------ content ------*/
  .content {
    background-color: rgba(245,245,245,0.95); text-align: left;
  }
  .content.popup {padding: 2.5em; padding-top: 3em; padding-bottom: 2.5em; font-size: 86%;}
  .content.page {padding: 2.5em; font-size: 90%;}
  @media all and (orientation:portrait) {
    .content.popup {padding: 1.25em; padding-top: 2.5em; padding-bottom: 1.5em;}
    .content.page {padding: 1.6em 1.25em; font-size: 86%;}
  }
  @media all and (orientation:portrait) and (min-width:601px) {
    .content.page {font-size: 95%;}
    .content.popup > .section.head > .text.title {font-size: 116%;}
  }
  .section {display: block;}
  .section.head {}
  .section.head > .text.title {display: block; padding-bottom: 0.25em;}
  .section.head > .text.sub {display: block;}
  .section.foot {}
  .section.main {margin-top: 2.5em;}
  .section.submain {margin-top: 2.0em;}
  .section.sub {margin-top: 1.5em;}
  .section.sub2 {margin-top: 0.6em;}
  .section.sub3 {margin-top: 0.3em;}
  .section.sub4 {margin-top: 0.1em;}
  .section.subline {margin-top: 0;}
  .section.indent {margin-left: 1.2em;}

  .section.page.main {margin-top: 3.2em;}


/*------ sliding container ------*/
  .slider {
    max-height: 50em; overflow-y: hidden;
  }
  .slider.em05, .slider.shortesthgt {max-height: 5em;}
  .slider.em10, .slider.shorthgt {max-height: 10em;}
  .slider.em20, .slider.shortmedhgt {max-height: 20em;}
  .slider.em30, .slider.medhgt {max-height: 30em;}
  .slider.em40, .slider.highmedhgt {max-height: 40em;}
  .slider.em50, .slider.highhgt {max-height: 50em;}
  .slider.em60, .slider.pagehgt {max-height: 60em;}
  .slider.em70, .slider.highpagehgt {max-height: 70em;}
  .slider.em80, .slider.scrollhgt {max-height: 80em;}
  .slider.opened {transition: max-height 1.2s ease-in;}
  .slider.closed {max-height: 0; transition: max-height 1.0s ease-out;}
  .slider.shorthgt.opened, .slider.shortmedhgt.opened {transition: max-height 1.0s ease-in;}
  .slider.shorthgt.closed, .slider.shortmedhgt.closed {transition: max-height 0.6s ease-out;}
  .slider.highhgt.opened, .slider.highmedhgt.opened {transition: max-height 2.0s ease-in;}
  .slider.highhgt.closed, .slider.highmedhgt.closed {transition: max-height 1.5s ease-out;}
  .slider.pagehgt.opened, .slider.highpagehgt.opened, .slider.scrollhgt.opened {transition: max-height 2s ease-in;}
  .slider.pagehgt.closed, .slider.highpagehgt.closed, .slider.scrollhgt.closed {transition: max-height 1.5s ease-out;}


/*------ covering and bug messages ------*/
  .cover {
    display: none; position: fixed; left: 0; top: 0; right: 0; bottom: 0; padding-top: 6em;
    background-color: rgba(80,80,80,0.6); font-size: 115%; color: rgba(250,250,250,0.95); text-align: center;
  }
  .msg {
    padding-left: 1.0em; padding-right: 1.0em;
    font-size: 110%; color: white;
  }
  @keyframes blink {
    10% {color: white;}
    15% {color: rgb(255,80,80);}
    20% {color: white;}
    25% {color: rgb(255,80,80);}
    30% {color: white;}
    35% {color: rgb(255,80,80);}
    40% {color: white;}
  }
  .msg.blink {
    animation-name: blink; animation-delay: 1.0s; animation-duration: 3s; animation-iteration-count: infinite;
  }

  .bug {
    display: block; padding: 0.2em; font-size: 95%; text-align: right;
    position: absolute; right: 0; top: 0; bottom: auto; 
    background-color: rgba(204,204,204,0.65);
  }
  .bug > .text.i {font-size: 90%;}
  .bug > .text {font-size: 75%;}


/*------ buttons ------*/
  .btnbar {display: inline-block;}
  .btn {background-color: transparent; color: #444; text-align: center; transition: background-color 0.75s, color 0.75s;}
  .btn {display: inline-block; min-width: 1.0em; margin: 0; padding: 0 0.2em;}
  .btn.icon {font-size: 80%; padding: 1.5em 1.4em;}
  .btn.box {border: 1px solid #aaa; /*background-color: rgba(204,204,204,0.7);*/}
  .btn.box.op, .btn.box.sys {
    border: 1px solid #c8c8c8; padding: 0.15em; padding-left: 0.4em; padding-right: 0.4em;
  }
  .btn.noshow {display: none;}
  .btn.hidden {opacity: 0.0; visibility: hidden;}
  .btn.toggle.closed {display: inline-block; opacity: 0.3; visibility: visible; cursor: auto;}
  .btn.toggle.opened {display: inline-block; opacity: 1.0; visibility: visible;}
  .btn:not(.closed):hover {cursor: pointer;}
  @media (hover: hover) {
    .btn:not(.closed):hover {color: red;}
    .btn.box:not(.closed):hover {background-color: #fff;}
  }
  .btn:active {color: red;}
  .btn.box:active {background-color: #fff;}
  .btn.box:disabled {border: 1px solid #ddd; background-color: rgba(235,235,235,0.95);}

  /*btn icons*/
  .btn:after, .btn:before {font-family: 'Lucida Sans Unicode','Arial',sans-serif;}

  .btn.closex:after {content: '\2716' ;}  /*&Close; 274e 2716 2573*/
  .btn.fold:after {content: '\2af6'; font-weight: bold;}   /*22ee 25b4 2259 225A 2227*/
  .btn.unfold:after, .btn.menu:after {content: '\2af6';}   /*22ee 25b4 2259 225A 2227*/
  .btn.open:after, .openfile:before {content: '\22EF' ;} /*&ctdot; 22ef*/
  .openfile:before {/*font-weight: bold;*/}
  .btn.prev:after {content: '\25C2' ;}   /*&lt; \003C  \25C2  25B5 21E6 */
  .btn.next:after {content: '\25B8' ;}   /*&gt; \003E 25b8 25B7  25B9 279E 27AD 21E8*/
  .btn.new:before {content: '\25B8  ' ;}   /*b8 littler*/
  .btn.fwd:after {content: '  \25B8 ' ;}   /**/
  .btn.rev:before {content: '\25C2  ' ;}   /**/
  .btn.stop:before {content: '\2981  ' ;}   /*2297(cirled x) 2716(big x) 2981(bold dot)*/

  .btn.undo:after {content: ' \21a9 ' ;}   /*293E*/
  .btn.undoall:after {content: ' \21ab ' ;}   /*2bbd (x in box)*/
  .btn.savefile:after {content: ' \22EF ' ;}   /**/

  .btn.openimg:after {content: '  \1f5cb ' ; font-weight: bold;}   /*page*/
  .btn.swap:before {content: ' \27F7  ' ;}   /*2194 2b80 21c4 21b6 21b7*/
  .btn.swap2:before {content: ' \21C4  ' ;}   /*21C4 2b80 2b0c 2b64*/

  .btn.xor:before {content: ' \2295  ' ;}   /*xor*/
  .btn.and:before {content: ' \2227  ' ;}   /*and*/
  .btn.or:before {content: ' \2228  ' ;}   /*or*/
  .btn.rand:after {content: '  \21BB ' ;}   /*21bb 2682 27ff*/
  .btn.magnifier:after {content: '  \2315 ';}
  .btn.alert:before {content: ' \26A0  ' ;}
  .btn.eye:before {content: ' \1f441 ' ;}
  .btn.link:after {content: '  \260D ';}
  .btn.hand:before, .btn.manip:before {content: '\1f591';}
  .btn.pin:before {content: ' \2299  ';}
  .btn.skull:after {content: '  \1f571 ';}
  .btn.worldmap:after {content: '  \1f5fa ';}
  .btn.finger:after {content: '  \261e ';}
  .btn.snowman:after {content: '  \2603 ';}
  .btn.star:after {content: '  \2606 ';}
  .btn.stopwatch:after {content: '  \23f1 ';}
  .btn.ringer:after {content: '  \1f6ce ';}
  .btn.calculator:after {content: '  \1f5a9 ';}
  .btn.diskette:after {content: '  \1f5ab ';}
  .btn.mona:after {content: '  \1f5bb ';}
  .btn.medal:after {content: '  \1f396 ';}
  .btn.plate:after {content: '  \1f37d ';}
  .btn.thermometer:after {content: '  \1f321 ';}
  .btn.mona:after {content: '  \1f5bb ';}
  .archive:before {content: '\2707  ' ;}   /*2707(tape) 1F4BE(floppy) 1F33B(sunflower)*/
  .btn.frosty:before {content: ' \2603  ' ;}   /*snowman*/
  .btn.tools:before, .program:before {content: ' \2692  ' ;}   /**/

  .btn.crosshaircenter:before {content: ' \25a1 ' ;}   /**/

  .btn.actualsize:before {content: ' \25a1 ' ;}
  .btn.fit:before {content: ' \25A3 ' ;}   /*block square in outline*/

  .btn.fit.enabled, .btn.actualsize.enabled {display: inline-block;}
  .btn.manip.enabled:before, .btn.menu.enabled:after {font-weight: bold;}

  /*print without btnbars*/
  @media print {
    .btnbar {display: none;}
  }


/*------ text ------*/
  .text {
    display: inline-block; position: relative; transition: color 0.9s ease;
  }
  .text.status {margin-left: 0.3em;}
  .text.truncate {max-width: 20em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; vertical-align: middle;}
  .text.ok {color: #283;}
  .text.err {color: #a00;}
  .text.clickable {}
  .text.i {font-style: italic;}
  .text.bold {font-weight: bold;}
  /*.text.tt {font-family: 'Courier New','Courier',monospace,serif; font-size:105%;}*/
  .text.tt {font-family: monospace; font-size:115%;}
  .text.head {font-size: 115%;}
  .text.title {font-size: 115%;}
  .text.title.chapter {font-weight: bold; font-size: 115%;}
  .text.title.sup {font-size: 93%;}
  .text.addendum, .text.foot, .text.small {font-size: 85%;}
  @media all and (orientation:portrait) {
    .text.head {font-size: 110%;}
    .text.title {font-size: 113%;}
  }
  a.text {color:rgb(20,40,160); text-decoration: underline;}
  a.text:visited {color: inherit;}
  a.text.tt {text-decoration:none; font-size:105%;}
  .text.clickable:hover {cursor: pointer;}
  @media (hover: hover) {
    .text.clickable:hover {color: red;}
    a.text:hover {text-decoration: underline;}
  }
  .text.clickable:active {color: red;}

  .text.icon:before {font-family: 'Lucida Sans Unicode','Arial',sans-serif; color:rgb(50,50,60); white-space: pre;}
  .text.icon:after     {content: '  ' ; white-space: pre;}
  .text.icon.r:before  {content: '\25B8  ' ;}   /**/
  .text.icon.l:before  {content: '\25C2  ' ;}   /**/
  .text.icon.sw:before {content: '\21C4  ' ;}   /*reverse arrows*/
  .text.icon.xo:before {content: '\2295  ' ;}   /*xor*/
  .text.icon.a:before  {content: '\2227  ' ;}   /*and*/
  .text.icon.o:before  {content: '\2228  ' ;}   /*or*/
  .text.icon.actualsize:before {content: '\25a1  ' ;}


/*------ inputs ------*/
  input, textarea {font-family: 'Courier New','Courier',monospace; font-size:100%;}
  /*input, textarea {font-family: monospace; font-size:120%;}*/
  input {
    border: 1px solid #ddd; background-color: transparent; text-overflow: ellipsis;
  }
  input.trigger {
    border-color: transparent;
  }
  input:hover, input:focus, textarea {
    border-color: #ccc; background-color: #fff;
  }
  input:disabled, textarea:disabled, button:disabled, .btnX:disabled {
    border: 1px solid #ddd; background-color: rgba(235,235,235,0.95);
  }
  input[type="checkbox"], input[type="radio"] {border: 0;}
  input.inpshort {width: 3em;}
  input.inp {width: 5em;}
  input.inp.float {width: 9em;}
  input.inplong {width: 16em;}
  input.inpplain {border-color: transparent;}
  input.inpbox, .inpbox:hover, .inpbox:focus {border: 0;}

  /* text areas */
  textarea {margin-bottom: 0.2em;}
  .json, .list {height: 15em; width: 28em; color: #555; font-size: 0.8em;}
  .json {width: 30em;}
  .json.long, .list.long {height: 20em;}
  @media all and (orientation:landscape) {
    .json {min-width: 25em;}
  }
  @media all and (orientation:portrait) {
    input[type=checkbox], input[type=radio] {width: 0.95em; height: 0.95em;}
    .json {height: 17em;}
    .list {height: 14em;}
    .json.long, .list.long {height: 14em;}
    .json, .list {width: 98%; max-width: 98%;}
  }
  @media all and (max-width:500px) and (orientation:portrait) {
    .list {height: 10em;}
  }


/*------ image arrangement ------*/
  .gallery, .captionedbox, .captionedbox > .thumb {
    position: relative; margin: 0; margin-top: 0.2em; border:0; padding: 0;
  }
  .gallery, .captionedbox {display: inline-block;}
  .captionedbox > .thumb, .captionedbox > .caption {display: block;}
  .captionedbox > .caption {font-size: 0.7em; line-height: 0.75em; font-style: italic;}
  img.thumb {max-width: 200px;}
  @media all and (min-width:600px) and (orientation:portrait) {
    img.thumb {max-width: 280px;}
  }


/*------ overrides ------*/
  .line {display: block;}
  .line.nowrap {white-space: nowrap;}
  .noshow {display: none;}
  .showblock {display: block;}
  .showinline {display: inline-block;}
  .vis {visibility: visible;}
  .hid {visibility: hidden;}
  .scrollable {overflow: auto;}
  .collapsible:empty {display: none;}
    </style>

<!--    <script src="../lib/image/imageproc.js"></script>  -->
    <script>
/*
 *  CanvasImage JS Library, copyright (c) 2023 Greg Sidal, MIT licence
 *
 *    CanvasImage.Image:       Image on canvas
 *    CanvasImage.Image.Data:  Sub of .Image, adds image data processing
 *    CanvasImage.File         Opens/saves image from/to urls/files, uses .Image
 *    CanvasImage.File.Data    Sub of .File, uses .Image.Data
 *
 *  CanvasImage.File primary functions:
 *
 *    Create:                  var cif = new CanvasImage.File( canvas, onnotify );
 *    Get .Image:              var ci = cif.getcanvasimageobj();
 *    Open image:              cif.setsrc( filename );
 *    Open url:                cif.setsrc( null, url );
 *    Save PNG:                <a href="" onclick="cif.getBmpDataUrl()" download="image.png">Save</a>
 *
 *                             onnotify( msg ): onnotify() called when setsrc(..) successfully completes
 *                                              onnotify(filename|url) called immediately before success
 *                                              onnotify("ERROR: <reason>") called when setsrc(..) fails
 *
 *  CanvasImage.File.Data (in addition to above):
 *
 *    Create:                  var cifd = new CanvasImage.File.Data( canvas, onnotify );
 *    Get .Image.Data:         var cid = cifd.getcanvasimagedataobj();
 *    Process rgba:            ci.process( processor, anyotherdata );
 *    Process rgb:             ci.processrgb( processor, anyotherdata );
 *
 *                             {data,width,height} = processor( {data,width,height}, anyotherdata )
 *                             data is rgba or rgb contiguous Uint8Array
 */


/*
 *  image on canvas
 */
CanvasImage = {};
CanvasImage.Image = function( canv ) {
  this.getsize = function() {
    return {wid: this.view.canvas.width, hgt: this.view.canvas.height};
  }
  this.setsize = function( wid, hgt ) {
    this.view.canvas.width = wid, this.view.canvas.height = hgt;
  }
  this.initfill = function( rgbcol ) {
    this.view.context.fillStyle = rgbcol ? rgbcol : 'rgb(255,255,255)';
    this.view.context.fillRect( 0, 0, this.view.canvas.width, this.view.canvas.height );
  }
  this.setimg = function( img ) {
    if (!img)
      return this.initfill();
    this.setsize( img.width, img.height );
    this.view.context.drawImage( img, 0, 0 );
  }
  this.getcanvas = function() {
    return this.view.canvas;
  }
  this.getcontext = function() {
    return this.view.context;
  }
  this.getmetadata = function() {
    return this.metadata;
  }
  this.setmetadata = function( part, md ) {
    if (part)
      this.metadata[part] = md;
  }
  /*constructor*/
  if (!canv) {
    canv = document.createElement( 'canvas' );
    canv.width = canv.height = 100;
  }
  this.view = {canvas:canv,context:canv.getContext('2d')};
  this.metadata = {};
  this.getcanvasimageobj = function() {return this;};
}


/*
 *  image data on canvas
 */
CanvasImage.Image.Data = function( canv ) {
  this.drawimg = function() {
    if (!this.src.data) {
      this.initfill();
      return false;
    }
    this.setsize( this.src.data.width, this.src.data.height );
    this.getcontext().putImageData( this.src.data, 0, 0 );
    return true;
  }
  this.setdata = function( data ) {
    this.src.data = data;
    return this.drawimg();
  }
  this.getdata = function() {
    if (!this.src.data)
      this.src.data = this.getviewdata();
    return this.src.data;
  }
  this.getviewdata = function() {
    return this.getcontext().getImageData( 0, 0, this.getsize().wid, this.getsize().hgt );
  }
  this.setimg = function( img ) {
    this.super.setimg( img );
    this.src.data = this.getviewdata();
  }
  this.getrgbdata = function() {
    return CanvasImage.Image.Data.Util.imgdata2rgb( this.getdata() );
  }
  this.getrgbadata = function() {
    return CanvasImage.Image.Data.Util.imgdata2rgba( this.getdata() );
  }
  this.rgb2imgdata = function( rgbdata, w, h ) {
    return CanvasImage.Image.Data.Util.rgb2imgdata( rgbdata, w, h );
  }
  this.rgba2imgdata = function( rgbdata, w, h ) {
    return CanvasImage.Image.Data.Util.rgba2imgdata( rgbdata, w, h );
  }
  this.process = function( processor, rgb, anyotherdata ) {
    var imgdata = this.getdata();
    var data = rgb ? this.getrgbdata() : this.getrgbadata();
    var processed = processor( {'data':data, width:imgdata.width, height:imgdata.height}, anyotherdata );
    if (processed) {
      data = rgb ? this.rgb2imgdata(processed.data,processed.width,processed.height) : 
                   this.rgba2imgdata(processed.data,processed.width,processed.height);
      this.setdata( data );
    }
    return processed;
  }
  this.processrgb = function( processor, anyotherdata ) {
    return this.process( processor, true, anyotherdata );
  }
  this.processrgba = function( processor, anyotherdata ) {
    return this.process( processor, false, anyotherdata );
  }

  this.src = {data:null};
  this.super = new CanvasImage.Image( canv );

  this.getcanvasimageobj = function() {return this;};
  this.getcanvasimagedataobj = function() {return this;};

  /* pass throughs */
  this.initfill = function(rgbcol) {return this.super.initfill(rgbcol);};
  this.getcanvas = function() {return this.super.getcanvas();};
  this.getcontext = function() {return this.super.getcontext();};
  this.getsize = function() {return this.super.getsize();};
  this.setsize = function(w,h) {return this.super.setsize(w,h);};
  this.setmetadata = function(d) {return this.super.setmetadata(d);};
  this.getmetadata = function() {return this.super.getmetadata();};
}


/*
 *  ImageData utils (lib)
 */
CanvasImage.Image.Data.Util = {
  /* unpack [rgbrgbrgb...] array into imgdata */
  rgb2imgdata: function( rgb, w, h ) {
    var idobj = new ImageData( w, h );
    if (!rgb)
      return idobj;
    var imgdata = idobj.data;
    var imgdatalen = imgdata.length;
    var rgblen = rgb.length;
    for( var i=0,j=0; j<rgblen && i<imgdatalen; i+=4,j+=3 )
      imgdata[i] = rgb[j], imgdata[i+1] = rgb[j+1], imgdata[i+2] = rgb[j+2], imgdata[i+3] = 255;
    return idobj;
  },
  /* unpack [rgbargbargba...] array into imgdata */
  rgba2imgdata: function( rgba, w, h ) {
    var idobj = new ImageData( w, h );
    if (!rgba)
      return idobj;
    var imgdata = idobj.data;
    var imgdatalen = imgdata.length;
    for( var i=0; i<imgdatalen; i+=4 )
      imgdata[i] = rgba[i], imgdata[i+1] = rgba[i+1], imgdata[i+2] = rgba[i+2], imgdata[i+3] = rgba[i+3];
    return idobj;
  },
  /* pack imgdata into [rgbrgbrgb...] array */
  imgdata2rgb: function( idobj ) {
    var imgdata = idobj.data;
    var imgdatalen = imgdata.length;
    var binarr = new Uint8Array( (imgdatalen/4) * 3);
    for( var i=0,j=0; i<imgdatalen; i+=4,j+=3 )
      binarr[j] = imgdata[i], binarr[j+1] = imgdata[i+1], binarr[j+2] = imgdata[i+2];
    return binarr;
  },
  /* pack imgdata into [rgbargbargba...] array */
  imgdata2rgba: function( idobj ) {
    var imgdata = idobj.data;
    var imgdatalen = imgdata.length;
    var binarr = new Uint8Array( imgdatalen );
    for( var i=0; i<imgdatalen; i+=4 )
      binarr[i] = imgdata[i], binarr[i+1] = imgdata[i+1], binarr[i+2] = imgdata[i+2], binarr[i+3] = imgdata[i+3];
    return binarr;
  },
  /* compare piece of image */
  compare: function( idobj, rgbarr, offset ) {
    offset = offset ? offset : 0;
    var imgdata = idobj.data;
    var len = imgdata.length;
    for( var i=offset,j=0; i<len && j<rgbarr.length; i++,j++ )
      if (imgdata[i] != rgbarr[j])
        return false;
    return true;
  },
  /* test if browser is blocking canvas data (Tor-like browsers) */
  test: function( forcedisallowcanvasdata ) {
    var ret = 'nocanvdata';
    try {
      var c = document.createElement( 'canvas' );
      c.width = c.height = 1;
      var cx = c.getContext( '2d' );
      var i = cx.getImageData( 0, 0, 1, 1 );
      i.data[0] = 10, i.data[1] = 20, i.data[2] = 30, i.data[3] = 255;
      cx.putImageData( i, 0, 0 );
      i = cx.getImageData( 0, 0, 1, 1 );
      if (forcedisallowcanvasdata)
        i.data[0] = 255;
      if (i.data[0] == 10 && i.data[1] == 20 && i.data[2] == 30 && i.data[3] == 255)
        ret = '';
    }
    catch( e ) {
      ret = 'nocanv';
    }
    return ret;
  }
};


/*
 *  image file on canvas
 */
CanvasImage.File = function( canv, callback, cii ) {
  this.loadimg = function() {
    var this_ = this;
    var callbacks = {
      onloadnotify: function(m,u,n) {this_.onnotify(m,u,n);},
      onloaded: function(d,u,n) {this_.getcanvasimageobj().setimg(d); this_.onnotify(n,u,n); this_.onnotify();},
      onerror: function(m,u,n) {this_.onnotify(m,u,n);}
    }
    if (this.src.file)
      FileHandler.loadimgfile( callbacks, this.src.file );
    else
      FileHandler.loadimgurl( callbacks, this.src.url );
  }
  this.onnotify = function( msg, url, name ) {
    if (this.callback)
      this.callback( msg, url, name );
  }
  this.setsrc = function( f, u ) {
    this.src.file = f;
    this.src.url = u;
    return this.loadimg();
  }
  this.getBmpDataUrl = function() {
    return this.cii.getcanvas().toDataURL( 'image/png', 1.0 );
  }
  this.cii = cii ? cii : new CanvasImage.Image( canv );
  this.src = {file:null, url:null};
  this.callback = callback;
  this.getcanvasimageobj = function() {return this.cii;};
  this.getcanvasimagefileobj = function() {return this;};
}


/*
 *  image file data on canvas
 */
CanvasImage.File.Data = function( canv, callback ) {

  this.ciid = new CanvasImage.Image.Data( canv );
  this.getcanvasimageobj = function() {return this.ciid.getcanvasimageobj();};
  this.getcanvasimagedataobj = function() {return this.ciid.getcanvasimageobj();};

  this.super = new CanvasImage.File( canv, callback, this.ciid );
  this.getcanvasimagefileobj = function() {return this;};

  /* pass throughs */
  this.getBmpDataUrl = function() {return this.super.getBmpDataUrl();};
  this.setsrc = function(f,u) {return this.super.setsrc(f,u);};
}


/*
 *  file handler
 */
var FileHandler = {
  /* Fetch image file from local drive */
  loadimgfile: function( callbacks, file ) {
    var reader = new FileReader();
    reader.onerror = function( e ) {callbacks.onerror('ERROR: could not open file '+file.name,file.name,file.name);}
    reader.onload = function( e ) {
      var img = new Image();
      img.onload = function() {callbacks.onloaded(img,file.name,file.name);}
      img.onerror = function() {callbacks.onerror('ERROR: '+file.name+' not a supported image file type', file.name, file.name);}
      img.src = e.target.result;
    }
    reader.readAsDataURL( file );
  },
  /* Fetch image file from web */
  loadimgurl: function( callbacks, url ) {
    var name = (url.slice(0,5) == 'data:') ? "" : url;
    function err( m ) {callbacks.onerror(m,url,name);}
    var img = new Image();
    img.onerror = function() {err('ERROR: url '+name+' not found, could not be loaded, or is invalid');}
    img.onload = function() {callbacks.onloaded(img,url,name);}
    try {
      img.src = url;
    }
    catch( e ) {
      err( "ERROR: " + name );
    }
  },
  /* Fetch binary file from web */
  loadurlbinary: function( callbacks, url ) {
    var name = (url.slice(0,5) == 'data:') ? "" : url;
    function progress( e ) {
      callbacks.onloadnotify( name + (!e.lengthComputable || e.loaded==e.total) ?
                                    '' : ' (loading '+((e.loaded*100)/e.total)+'%)', url, name );
    }
    function complete( e ) {
      callbacks.onloaded( new Uint8Array(this.response), url, name );
    }
    function err( m ) {callbacks.onerror(m,url,name);}
    function failed() {err(this.status==404 ? "URL not found" : "Server busy");}
    function canceled( e ) {err( "Canceled" );}
    callbacks.onloadnotify( u );
    try {
      var req = new XMLHttpRequest();
      req.addEventListener( "progress", progress, false );
      req.addEventListener( "load", complete, false );
      req.addEventListener( "error", failed, false );
      req.addEventListener( "abort", canceled, false );
      req.open( "GET", url, true );
      req.responseType = "arraybuffer";
      req.send();
    }
    catch( e ) {
      err( "ERROR: " + url );
    }
  }
}
    </script>

<!--    <script src="../uiutil.js"></script>  -->
    <script>
/*
 *  UI Utilities, 2023 Greg Sidal, MIT licence
 *
 *    UI.Manipulator:       Adds pan/pinch-zoom/hold-zoom to elem
 *    UI.manipulation:      Attaches UI.Manipulators to elems
 *    UI.transform.css:     Cumulative matrix tranforms on elem
 *    UI.transform.matrix:  4x4 matrix ops
 *    UI.NCEventEmitter:    Emits non-conflicting hold, multi-drag, click, dblclick events
 *    UI.PointerEventShim:  Low-level pointer events with multi-touch simulation on hover devices
 *    UI.responsive:        Sets css class names on elems to indicate size and position (for responsive tweaks)
 *    UI.class:             Elem class list management helpers
 *    UI.view:              View helpers
 *    UI.util:              Basic helpers
 *
 *  id: either Id string or HTMLElement
 */
var UI = {};


/*
 * UI.Manipulator: pan/pinch-zoom/hold-zoom
 *
 *   ctrl-hold:   alternating zoom in/out
 *   dblclick:    fit-center
 *   drag:        pan
 *   multidrag:   pinch-zoom on multi-pointer devices
 *
 *   start:       var m = new UI.Manipulator( idOrElem[, defs[, idvp]] )
 *   stop:        m.disable()
 *   listen:      m.setstatechangelistener( callback )
 *
 *   idvp:        plain viewport container; default immediate parent (no borders or padding)
 *   callback:    function( elem, states ); states={actualsize, fitted, moved, zoomed}
 *
 * sets/removes css classes defs.css['panning'], defs.css['zooming-in'], and defs.css['zooming-out']
 * defs.scalefactor.dec, defs.scalefactor.inc are the factors used to decrease and increase scale
 * defs.eventemitter.multisim==true: enable multi-touch simulator (see UI.PointerEventShim)
 */
UI.Manipulator = function( id, defs, idvp ) {
  var elem = UI.el( id );
  var vpelem = idvp ? UI.el(idvp) : UI.getparent( elem );
  var emitter = null;
  var zoomdir = false;
  var held = false;
  var panning = 0;
  var states = {};
  var onstatechg = null;
  this.enable = function() {
    var callbacks = {
      click2: function( el, ptr ) {
        /* zoom in or out by factor */
        var sf = zoomdir ? UI.manipulation.getdef(defs).scalefactor.dec
                           : UI.manipulation.getdef(defs).scalefactor.inc;
        UI.transform.css.zoom( el, {x:sf, y:sf}, vppos(ptr.pos) );
        chgstates( ['scaled'] );
      },
      click: function( el, ptr ) {
        if (canhover( ptr.event )) {
          callbacks.click2( el, ptr, true );
          zoomdir = zoomdir ? false : true;
        }
      },
      hold: function( el, ptr, prevholdpos ) {
        if (!ptr.event.ctrlKey) //(!canhover( ptr.event ))
          callbacks.holdend( el, ptr );
        else
          if (samepos( ptr.pos, prevholdpos )) {
            held = true;
            UI.manipulation.remclass( el, 'panning', defs );
            UI.manipulation.addclass( el, zoomdir ? 'zooming-out' : 'zooming-in', defs );
            callbacks.click2( el, ptr );
          }
      },
      holdend: function( el, ptr ) {
        if (held) {
          UI.manipulation.remclass( el, 'zooming-in', defs );
          UI.manipulation.remclass( el, 'zooming-out', defs );
          zoomdir = zoomdir ? false : true;
          held = false;
        }
      },
      dblclick: function( el, ptr ) {
        fit();
        zoomdir = false;
      },
      drag: function( el, ptrs, i ) {
        if (ptrs.length == 1) {
          UI.manipulation.addclass( el, 'panning', defs );
          /* pan */
          UI.transform.css.pan( el, vppos(ptrs[i].pos), vppos(ptrs[i].prevpos) );
          chgstates( ['moved'] );
          panning = true;
        }
        else
          if (ptrs.length == 2) {
            UI.manipulation.addclass( el, 'panning', defs );
            UI.manipulation.addclass( el, 'zooming-in', defs );
            UI.manipulation.addclass( el, 'zooming-out', defs );
            /* pinch-zoom */
            var pos = [vppos(ptrs[i].pos), vppos(ptrs[i?0:1].pos)];
            var prevpos = [vppos(ptrs[i].prevpos), vppos(ptrs[i?0:1].prevpos)];
            UI.transform.css.pinchzoom( el, pos, prevpos );
            chgstates( ['moved', 'scaled'] );
          }
      },
      dragend: function( el, ptrs, i ) {
        if (ptrs.length == 1) {
          UI.manipulation.remclass( el, 'panning', defs );
          panning = false;
        }
        else
          if (ptrs.length == 2) {
            UI.manipulation.remclass( el, 'zooming-in', defs );
            UI.manipulation.remclass( el, 'zooming-out', defs );
            if (!panning)
              UI.manipulation.remclass( el, 'panning', defs );
          }
      }
    }
    emitter = new UI.NCEventEmitter( elem, callbacks, UI.manipulation.getdef(defs).eventemitter );
    fit();
    return true;
  }
  this.disable = function() {
    UI.manipulation.remclass( elem, 'panning', defs );
    UI.manipulation.remclass( elem, 'zooming-in', defs );
    UI.manipulation.remclass( elem, 'zooming-out', defs );
    emitter.disable();
    //UI.transform.css.clear( id );
    UI.remstyle( elem, 'transform-origin' );
    UI.remstyle( elem, 'transform' );
    resetstates( [] );
    return true;
  }
  var vppos = function( pos, ev ) {
    var r = vpelem.getBoundingClientRect();
    return {x: pos.x - r.left, y: pos.y - r.top};
  }
  var resz = function() {
    if (!transformed())
      return states.fitted ? fit( true ) : (states.actualsize ? actualsize( true ) : false);
  }
  var fit = function( resize ) {
    if (!states.fitted || resize) {
      UI.view.centerfit( elem, UI.manipulation.getdef(defs).fit );
      resetstates( ['fitted'] );
    }
    return states.fitted;
  }
  var actualsize = function( resize ) {
    if (!states.actualsize || resize) {
      UI.view.center( elem, 1.0/(window.devicePixelRatio?window.devicePixelRatio:1.0) );
      resetstates( ['actualsize'] );
    }
    return states.actualsize;
  }
  var chgstates = function( ns ) {
    states.fitted = false, states.actualsize = false;
    for( var i=0; i<ns.length; i++ )
      states[ns[i]] = true;
    if (onstatechg)
      onstatechg( elem, states );
  }
  var resetstates = function( ns ) {
    states = {};
    chgstates( ns );
  }
  var reportstates = function() {
    if (onstatechg)
      onstatechg( elem, states );
  }
  var transformed = function() {return states.scaled || states.moved;}
  var canhover = function( ev ) {
    if (ev.ctrlKey && UI.manipulation.getdef(defs).eventemitter.multisim)
      return UI.devicecanhover();
    return ev.ctrlKey || UI.devicecanhover();
  }
  var samepos = function( pos1, pos2 ) {return UI.transform.algebra.samepos( pos1, pos2 );}
  this.init = function() {return reset( true );}
  this.getelem = function() {return elem;}
  this.changed = function() {return transformed();}
  this.getstates = function() {return states;}
  this.setstatechangelistener = function( listener ) {onstatechg = listener; reportstates();};
  this.resize = function() {resz();}
  this.reset = function( vw ) {
    vw == 'fit' ? fit() : (vw == 'actualsize' ? actualsize() : resz());
  }
  this.enable();
}


/*
 * UI.manipulation: controller for Manipulators
 *
 *   create: UI.Manipulator = UI.manipulator.create( idOrElem )
 *   delete: UI.manipulator.delete( idOrElem )
 */
UI.manipulation = {
  defaultdefs: {
    css: {
      'panning':     'manip-panning',
      'zooming-in':  'manip-zooming-in',
      'zooming-out': 'manip-zooming-out'
    },
    scalefactor: {
      dec: 0.85,
      inc: 1.15
    },
    fit: {
      portrait: {position: 'top', tweak: {high: 0.0, medhigh: 0.03, short: 0.06, dwarf: 0.10}},
      landscape: {position: 'center'}
    },
    eventemitter: {multisim: false}
  },
  getdef: function( d ) {
    var defs = d ? d : UI.manipulation.defaultdefs;
    defs.css = defs.css ? defs.css : UI.manipulation.defaultdefs.css;
    defs.scalefactor = defs.scalefactor ? defs.scalefactor : UI.manipulation.defaultdefs.scalefactor;
    defs.fit = defs.fit ? defs.fit : UI.manipulation.defaultdefs.fit;
    defs.eventemitter = defs.eventemitter ? defs.eventemitter : UI.manipulation.defaultdefs.eventemitter;
    return defs;
  },
  addclass: function( id, n, defs ) {UI.addclass( id, UI.manipulation.getdef(defs).css[n] );},
  remclass: function( id, n, defs ) {UI.remclass( id, UI.manipulation.getdef(defs).css[n] );},
  elems: [],
  find: function( id ) {
    return UI.manipulation.elems.findIndex( function(m) {return m.getelem() == UI.el(id);} );
  },
  getmanipulator: function( id ) {
    var i = UI.manipulation.find( id );
    return (i<0) ? null : UI.manipulation.elems[i];
  },
  create: function( id, defs ) {
    var m = UI.manipulation.getmanipulator( id );
    if (!m) {
      m = new UI.Manipulator( id, defs );
      UI.manipulation.elems.push( m );
    }
    return m;
  },
  delete: function( id ) {
    var m = UI.manipulation.getmanipulator( id );
    if (m) {
      m.disable();
      UI.manipulation.elems.splice( UI.manipulation.find(id), 1 );
    }
    return m;
  }
}


/*
 * UI.transform.css: cumulative css transforms on elem
 *   UI.transform.css.pandelta( id, delta )         cumulative pan
 *   UI.transform.css.pan( id, topt, frompt )       cumulative pan
 *   UI.transform.css.panto( id, pos )              non-cumulative pan
 *   UI.transform.css.zoom( id, scale, origin )     cumulative zoom
 *   UI.transform.css.zoomnew( id, scale, origin )  non-cumulative zoom
 *   UI.transform.css.panzoom( id, scale, origin, delta )
 *     pan and zoom; cumulative
 *   UI.transform.css.pinchzoom( id, pts, prevpts )
 *     do a "pinchzoom" by introspecting changes between two pts; cumulative
 *
 * UI.transform.matrix: 4x4 matrix ops
 * UI.transform.algebra: helper math
 *
 * matrices always 4x4; params either 3D or 2D, eg. {delta.x, delta.y[, delta.z]}
 */
UI.transform = { 
  matrix: {
    identity: [ [ 1,    0,    0,    0    ], 
                [ 0,    1,    0,    0    ], 
                [ 0,    0,    1,    0    ], 
                [ 0,    0,    0,    1    ] ],
    /*
    translate:[ [ 1,    0,    0,    'Tx' ], 
                [ 0,    1,    0,    'Ty' ], 
                [ 0,    0,    1,    'Tz' ], 
                [ 0,    0,    0,    1    ] ],

    scale:    [ [ 'Sx', 0,    0,    0    ], 
                [ 0,    'Sy', 0,    0    ], 
                [ 0,    0,    'Sz', 0    ], 
                [ 0,    0,    0,    1    ] ],
    */
    mkidentity: function() {
      return UI.transform.matrix.copy( UI.transform.matrix.identity );
    },
    mktranslate: function( offset ) {
      offset = UI.transform.matrix.defaultparam( offset, 0 );
      var m = Util.copy( UI.transform.matrix.identity );
      m[0][3] = offset.x;
      m[1][3] = offset.y;
      m[2][3] = offset.z;
      return m;
    },
    mkscale: function( scale ) {
      scale = UI.transform.matrix.defaultparam( scale, 1 );
      var m = Util.copy( UI.transform.matrix.identity );
      m[0][0] = scale.x;
      m[1][1] = scale.y;
      m[2][2] = scale.z;
      return m;
    },
    multiply: function( m1, m2 ) {
      var res = [];
      for( var i=0; i<m1.length; i++ ) {
        res[i] = [];
        for( var j=0; j<m2[0].length; j++ ) {
          var sum = 0;
          for( var k=0; k<m1[0].length; k++ )
            sum += m1[i][k] * m2[k][j];
          res[i][j] = sum;
        }
      }
      return res;
    },
    copy: function( m ) {
      return UI.transform.matrix.multiply( UI.transform.matrix.identity, m );
    },
    defaultparam: function( pin, def ) {
      pin = pin ? pin : {};
      var p = {};
      p.x = pin.x == undefined ? def : pin.x;
      p.y = pin.y == undefined ? def : pin.y;
      p.z = pin.z == undefined ? def : pin.z;
      return p;
    },
    translate: function( offset, m ) {
      m = m ? m : UI.transform.matrix.mkidentity();
      return UI.transform.matrix.multiply( UI.transform.matrix.mktranslate(offset), m );
    },
    scale: function( scale, origin, m ) {
      origin = UI.transform.matrix.defaultparam( origin, 0 );
      m = UI.transform.matrix.translate( {x:-origin.x, y:-origin.y, z:-origin.z}, m );
      m = UI.transform.matrix.multiply( UI.transform.matrix.mkscale(scale), m );
      return UI.transform.matrix.translate( {x:origin.x, y:origin.y, z:origin.z}, m );
    }
  },
  css: {
    fromstr: function( ts ) {
      var m = UI.transform.matrix.mkidentity();
      if (!ts)
        return m;
      ts = ts.split( 'matrix(' );
      if (ts.length != 2)
        ts = ts[0].split( 'matrix3d(' );
      if (ts.length != 2)
        return m;
      ts = ts[1].split( ')' );
      if (ts.length != 2)
        return m;
      var toks = ts[0].split( ',' );
      if (toks.length == 16) {
        /*
        [ [ a,    e,    i,    m ], 
          [ b,    f,    j,    n ], 
          [ c,    g,    k,    o  ], 
          [ d,    h,    l,    p  ] ]
        */
        for( var i=0; i<4; i++ )
          for( var j=0; j<4; j++ )
            m[j][i] = parseFloat( toks[i*j] );
      }
      else
        if (toks.length == 6) {
          /*
          [ [ a,    c,    0,    e ], 
            [ b,    d,    0,    f ], 
            [ 0,    0,    1,    0  ], 
            [ 0,    0,    0,    1  ] ] 
          */
          m[0][0] = parseFloat( toks[0] );
          m[0][1] = parseFloat( toks[2] );
          m[0][3] = parseFloat( toks[4] );
          m[1][0] = parseFloat( toks[1] );
          m[1][1] = parseFloat( toks[3] );
          m[1][3] = parseFloat( toks[5] );
        }
      return m;
    },
    tostr: function( m ) {
      m = m ? m : UI.transform.matrix.mkidentity();
      var mstr = "matrix3d(";
      for( var i=0, k=0; i<4; i++ )
        for( var j=0; j<4; j++, k++ )
          mstr += (k ? "," : "") + m[j][i];
      mstr += ")";
      return mstr;
    },
    from: function( id ) {
      var t = UI.style( id, 'transform' );
      return UI.transform.css.fromstr( t );
    },
    to: function( id, m ) {
      UI.setstyle( id, 'transform-origin', "0 0 0" );
      UI.setstyle( id, 'transform', UI.transform.css.tostr(m) );
    },
    pandelta: function( id, delta ) {
      var m = UI.transform.css.from( id );
      m = UI.transform.matrix.translate( delta, m );
      //console.log( "pan MATRIX: " + JSON.stringify(m) );
      UI.transform.css.to( id, m );
    },
    pan: function( id, topt, frompt ) {
      UI.transform.css.pandelta( id, UI.transform.algebra.delta(topt,frompt) );
    },
    panto: function( id, pos ) {
      m = UI.transform.matrix.translate( pos );
      UI.transform.css.to( id, m );
    },
    zoom: function( id, scale, origin ) {
      var m = UI.transform.css.from( id );
      m = UI.transform.matrix.scale( scale, origin, m );
      //console.log( "addzoom MATRIX: " + JSON.stringify(m) );
      UI.transform.css.to( id, m );
    },
    zoomnew: function( id, scale, origin ) {
      var m = UI.transform.matrix.scale( scale );
      m = UI.transform.matrix.translate( origin, m );
      UI.transform.css.to( id, m );
      //console.log( "newzoom MATRIX: " + JSON.stringify(m) );
    },
    panzoom: function( id, scale, origin, delta ) {
      var m = UI.transform.css.from( id );
      m = UI.transform.matrix.translate( delta, m );
      m = UI.transform.matrix.scale( scale, origin, m );
      //console.log( "panzoom MATRIX: " + JSON.stringify(m) );
      UI.transform.css.to( id, m );
    },
    /* do a "pinchzoom" by introspecting changes between two pts */
    pinchzoom: function( id, pts, prevpts ) {
      /* pan by change in midpts */
      var mid = {prev: UI.transform.algebra.midpt( prevpts[1], prevpts[0] ),
                 cur: UI.transform.algebra.midpt( pts[1], pts[0] )};
      var delta = UI.transform.algebra.delta( mid.cur, mid.prev );
      /* scale by change in distance between pts */
      var dist = {prev: UI.transform.algebra.distance( prevpts[1], prevpts[0] ),
                  cur: UI.transform.algebra.distance( pts[1], pts[0] )};
      var scale = dist.prev ? (dist.cur / dist.prev) : 1.0;
      scale = Math.max( Math.min(scale,10), 0.1 );
      //console.log( "PINCHZOOM: dist: " + JSON.stringify(dist) + ",  scale: " + scale );
      UI.transform.css.panzoom( id, {x:scale, y:scale}, mid.prev, delta );
    },
    clear: function( id ) {
      UI.transform.css.to( id );
    }
  },
  algebra: {
    distance: function( pt1, pt0 ) {
      return Math.hypot( pt1.x - pt0.x, pt1.y - pt0.y );
    },
    midpt: function( pt1, pt0 ) {
      return {x: (pt0.x + pt1.x) / 2, y: (pt0.y + pt1.y) / 2};
    },
    delta: function( pt1, pt0 ) {
      return {x: pt1.x - pt0.x, y: pt1.y - pt0.y};
    },
    samepos: function( pos1, pos2 ) {
      var delta = UI.transform.algebra.delta( pos1, pos2 );
      return (delta.x == 0 && delta.y == 0);
    }
  }
};


/*
 * UI.NCEventEmitter
 *
 * Emits non-conflicting click, drag, multidrag, dblclick, hold events for elem
 *
 *   start:    var ee = new UI.NCEventEmitter( elemOrID, callbacks[, defs] )
 *   stop:     ee.disable()
 *
 *   callbacks.dblclick:    two clicks in same place within defs.dblclick.delay
 *   callbacks.click:       down+up in same place (fires after defs.dblclick.delay)
 *   callbacks.holdstart:   hold in same place for defs.hold.duration.start
 *   callbacks.hold:        during hold, fires every defs.hold.duration.strobe
 *   callbacks.holdend:     hold released
 *   callbacks.drag:        pointer(s) moving
 *   callbacks.dragend:     drag ended (at least one pointer released)
 *
 * UI.Manipulator implements pan, hold-zoom, pinch-zoom
 */
UI.NCEventEmitter = function( id, _callbacks, _defs ) {
  var callbacks = _callbacks;
  var initcb = function( fn ) {callbacks[fn] = callbacks[fn] ? callbacks[fn] : function(){}};
  initcb( 'click' ), initcb( 'keyclick' ), initcb( 'dblclick' ), initcb( 'keydblclick' );
  initcb( 'holding' ), initcb( 'keyholding' ), initcb( 'holdend' );
  initcb( 'drag' ), initcb( 'dragend' ), initcb( 'keydrag' ), initcb( 'multidrag' ), initcb( 'keymultidrag' );
  var defs = _defs ? _defs : {};
  defs.dblclick = defs.dblclick ? defs.dblclick : {delay: 250};
  defs.hold = defs.hold ? defs.hold : {duration: {start: 500, strobe: 500}};
  defs.multisim = defs.multisim ? true : false;
  var lastclick = null;
  var hold = null;
  var el = UI.el( id );
  var handlers = {
    ptrdown: function( el, ptrs, i ) {
      ptrs[i].event.preventDefault();
      handlers.clearhold();
      if (ptrs.length == 1)
        handlers.starthold( ptrs[i] );
    },
    ptrmove: function( el, ptrs, i ) {
      ptrs[i].event.preventDefault();
      handlers.clearpendingclick();
      if (!handlers.held())
        handlers.clearhold();
      callbacks.drag( el, ptrs, i );
    },
    ptrup: function( el, ptrs, i ) {
      ptrs[i].event.preventDefault();
      var held = handlers.clearhold();
      if (ptrs.length == 1) {
        if (!ptrs[i].moved)
          handlers.processclick( el, ptrs[i], held );
      }
      if (ptrs[i].moved)
        callbacks.dragend( el, ptrs, i );
    },
    startpendingclick: function( el, ptr ) {
      lastclick = {'ptr': ptr, time: (new Date()).getTime()};
      setTimeout( handlers.click, defs.dblclick.delay );
    },
    clearpendingclick: function() {
      if (lastclick)
        clearTimeout( handlers.click );
      lastclick = null;
    },
    processclick: function( el, ptr, held ) {
      if (lastclick) {
        if (!elapsed( lastclick.time, defs.dblclick.delay )) {
          callbacks.dblclick( el, ptr );
          handlers.clearpendingclick();
        }
      }
      else
        if (!held)
          handlers.startpendingclick( el, ptr );
    },
    click: function() {
      if (lastclick) {
        var ptr = lastclick.ptr;
        handlers.clearpendingclick();
        callbacks.click( el, ptr );
      }
    },
    starthold: function( ptr ) {
      hold = {'ptr': ptr, held: 0, prevpos: {x: ptr.pos.x, y: ptr.pos.y}};
      setTimeout( handlers.hold, defs.hold.duration.start );
    },
    hold: function() {
      if (hold) {
        setTimeout( handlers.hold, defs.hold.duration.strobe );
        callbacks.hold( el, hold.ptr, hold.prevpos, hold.held );
        hold.prevpos = {x: hold.ptr.pos.x, y: hold.ptr.pos.y};
        //console.log( "HOLD "+ JSON.stringify(hold) );
        hold.held++;
      }
    },
    held: function() {
      return (hold && hold.held) ? hold.held : 0;
    },
    clearhold: function() {
      clearTimeout( handlers.hold );
      var held = handlers.held();
      if (hold) {
        var ptr = hold.ptr;
        hold = null;
        if (held)
          callbacks.holdend( el, ptr, held );
      }
      return held;
    }
  };
  var pes = new UI.PointerEventShim( el, handlers, {multisim: defs.multisim} );
  this.enable = function() {
    pes.enable();
  };
  this.disable = function() {
    clearTimeout( handlers.hold );
    clearTimeout( handlers.click );
    pes.disable();
  };
  var elapsed = function( time, delay ) {
    var deadtime = time + delay;
    var curtime = (new Date()).getTime();
    return curtime >= deadtime;
  };
};


/*
 * UI.PointerEventShim: wrapper for pointers API with multi-touch simulation on hover devices
 *
 *   start:    var pes = new UI.PointerEventShim( elemOrID, callbacks[, opts] )
 *   stop:     pes.disable()
 *
 *   callbacks.ptrdown: function( elem, pointers, evpointerindex )
 *   callbacks.ptrmove: function( elem, pointers, evpointerindex )
 *   callbacks.ptrup:   function( elem, pointers, evpointerindex )
 *
 *   pointers: active pointers with start, previous, and current positions for each
 *   evpointerindex: pointer that caused event to emit
 *   pointers[evpointerindex].event: event struct from browser
 *
 * move events are drags (hover events do not emit)
 * out, leave, and cancel events emit ptrup event; one ptrup will fire for each ptrdown
 * (See UI.Manipulator for implementations of pan, pinch-zoom, hold-zoom)
 *
 * Multi-touch simulation (opts.multisim defined):
 *
 *   Works when using desktop browser's mobile emulator in devtools (Chrome)
 *   Ctrl-click is treated as if "finger" remains on surface (ptrup event suppressed)
 *   Subsequent drags fire events with multiple pointers
 *   Alt-click releases the last saved point; treated as if that "finger" is lifted off surface
 *   Alt-click also emits the suppressed ptrup (w cached Event struct from actual ptrup)
 */
UI.PointerEventShim = function( id, _callbacks, opts ) {
  var initcb = function( fn ) {callbacks[fn] = callbacks[fn] ? callbacks[fn] : function(){}};
  var callbacks = _callbacks; initcb( 'ptrdown' ), initcb( 'ptrmove' ), initcb( 'ptrup' );
  opts = opts ? opts : {};
  var activeptrs = [];
  var el = UI.el( id );
  var handlers = {
    ptrdown: function( ev ) {
      var i = findactiveptr( ev.pointerId );
      if (i >= 0)
        return;
      var pos = evpos( ev );
      activeptrs.push( {ptrid:    ev.pointerId ? ev.pointerId : 1,
                        event:    ev, 
                        'pos':    pos, 
                        startpos: pos, 
                        prevpos:  pos} );
      var i = activeptrs.length-1;
      debugptr( 'PtrDOWN', i );
      return callbacks.ptrdown( el, activeptrs, i );
    },
    ptrmove: function( ev ) {
      var i = findactiveptr( ev.pointerId );
      if (i < 0)
        return;
      for( var j=0; j<activeptrs.length; j++ )
        activeptrs[j].prevpos = activeptrs[j].pos;
      activeptrs[i].pos = evpos( ev );
      activeptrs[i].moved = true;
      activeptrs[i].event = ev;
      return callbacks.ptrmove( el, activeptrs, i );
    },
    ptrup: function( ev ) {
      i = findactiveptr( ev.pointerId );
      if (i < 0)
        return;
      if (opts.multisim && initsim != sim())
        return alert( "PointerEventShim simulation mode changed - reload required" );
      /* (position should only change during move, so this code probably not needed) */
      for( var j=0; j<activeptrs.length; j++ )
        activeptrs[j].prevpos = activeptrs[j].pos;
      activeptrs[i].pos = evpos( ev );
      /* */
      activeptrs[i].event = ev;
      debugptr( 'PtrUP', i );
      var ret = callbacks.ptrup( el, activeptrs, i );
      activeptrs.splice( i, 1 );
      return ret;
    },
    ptrdownsim: function( ev ) {
      if (ev.altKey)
        return;
      return handlers.ptrdown( ev );
    },
    ptrmovesim: function( ev ) {
      if (ev.altKey)
        return;
      return handlers.ptrmove( ev );
    },
    ptrupsim: function(ev ) {
      if (ev.altKey) {
        for( var i=activeptrs.length-1; i>=0 && !activeptrs[i].sim; i-- );
        if (i < 0)
          return;
        ev = activeptrs[i].sim.ptrupevent;
      }
      else
        if (ev.ctrlKey) {
          var i = findactiveptr( ev.pointerId );
          if (i < 0)
            return;
          activeptrs[i].sim = {ptrupevent: ev};
          return;
        }
      return handlers.ptrup( ev );
    },
    toptrup: function( thisev, consolemsg ) {
      //console.log( consolemsg + thisev.pointerId );
      if (!initsim)
        return handlers.ptrup( thisev );
    },
    ptrout: function( thisev ) {
      return handlers.toptrup( thisev, "event pointerout Id=" );
    },
    ptrleave: function( thisev ) {
      return handlers.toptrup( thisev, "event pointerleave Id=" );
    },
    ptrcancel: function( thisev ) {
      return handlers.toptrup( thisev, "event pointercancel Id=" );
    }
  };
  this.enable = function() {
    if (UI.util.haspointers( el )) {
      el.addEventListener( 'pointerdown', initsim ? handlers.ptrdownsim : handlers.ptrdown );
      el.addEventListener( 'pointermove', initsim ? handlers.ptrmovesim : handlers.ptrmove );
      el.addEventListener( 'pointerup', initsim ? handlers.ptrupsim : handlers.ptrup );
      el.addEventListener( 'pointerout', handlers.ptrout );
      el.addEventListener( 'pointercancel', handlers.ptrcancel );
      el.addEventListener( 'pointerleave', handlers.ptrleave );
    }
    else {
      el.addEventListener( 'mousedown', handlers.ptrdown );
      el.addEventListener( 'mousemove', handlers.ptrmove );
      el.addEventListener( 'mouseup', handlers.ptrup );
      el.addEventListener( 'mouseout', handlers.ptrup );
      el.addEventListener( 'mousecancel', handlers.ptrup );
      el.addEventListener( 'mouseleave', handlers.ptrup );
    }
  };
  this.disable = function() {
    if (UI.util.haspointers( el )) {
      el.removeEventListener( 'pointerdown', initsim ? handlers.ptrdownsim : handlers.ptrdown );
      el.removeEventListener( 'pointermove', initsim ? handlers.ptrmovesim : handlers.ptrmove );
      el.removeEventListener( 'pointerup', initsim ? handlers.ptrupsim : handlers.ptrup );
      el.removeEventListener( 'pointerout', handlers.ptrout );
      el.removeEventListener( 'pointercancel', handlers.ptrcancel );
      el.removeEventListener( 'pointerleave', handlers.ptrleave );
    }
    else {
      el.addEventListener( 'mousedown', handlers.ptrdown );
      el.addEventListener( 'mousemove', handlers.ptrmove );
      el.addEventListener( 'mouseup', handlers.ptrup );
      el.addEventListener( 'mouseout', handlers.ptrup );
      el.addEventListener( 'mousecancel', handlers.ptrup );
      el.addEventListener( 'mouseleave', handlers.ptrup );
    }
  }
  var evpos = function( ev ) {return {x: ev.clientX, y: ev.clientY};}
  var findactiveptr = function( ptrid ) {
    ptrid = ptrid ? ptrid : 1;
    return activeptrs.findIndex( function(p) {return p.ptrid == ptrid;} );
  }
  var debugptr = function( act, i ) {
    if (opts.multisim)
      console.log( act + ": " + activeptrs.length + " pointers, " + 
                            "(current: index=" + i + ", id=" + activeptrs[i].ptrid + ")" );
    //console.log( "pointers array: " + JSON.stringify(activeptrs) );
  };
  var sim = function() {return (opts.multisim && !UI.devicecanhover());};
  var initsim = sim();
  this.enable();
};


/*
 * UI.responsive: sets css names for responsive tweaking; also panning/zooming using UI.manipulation
 *
 * Css classes using the names can be defined to adjust size/position, change cursors, etc.
 *
 * setresizeview( id[, idcontainer] ): default
 * setmanipview( id[, idcontainer] ):  attach UI.Manipulator
 * resize( [id[, idcontainer]] ):      changes class names to reflect new size (called from body.onresize)
 * init( [id[, idcontainer]] ):        initializes; looks for 'manip' or 'resize' (default) in class list
 *
 * init(), resize(): all elems with 'responsive' in class list targeted
 * idcontainer: default immediate parent
 */
UI.responsive = {
  defs: {
    css: {
      responsive:  'responsive',       //elem targeted during init, resize
      /* modes */
      manip:       'resp-manip',       //elem will have UI.Manipulator attached
      resize:      'resp-resize',      //default (typically css will fit/center)
      /* sizing indicators */
      small:       'resp-small',       //both wid/hgt too small for container
      tall:        'resp-tall',        //too tall
      wide:        'resp-wide',        //too wide
      aspecttall:  'resp-aspecttall',  //too tall if fitted to wid
      aspectwide:  'resp-aspectwide',  //too wide if fitted to hgt
      high:        'resp-high',        //high in container
      medhigh:     'resp-medhigh',     //med high in container
      short:       'resp-short',       //short in container
      dwarf:       'resp-dwarf'        //very short in container
    },
    szmodes: ['small', 'tall', 'wide', 'aspectwide', 'aspecttall','high','medhigh','short','dwarf']
  },
  getresponsiveelems: function() {return document.getElementsByClassName( UI.responsive.mode2class('responsive') );},
  processelems: function( processor ) {return UI.processelems( UI.responsive.mode2class('responsive'), processor );},
  ismanipview: function( id ) {return UI.responsive.hasmode( id, 'manip' );},
  isresizeview: function( id ) {return UI.responsive.hasmode( id, 'resize' );},
  mode2class: function( mode ) {
    if (!mode || !UI.responsive.defs.css[mode])
      throw( "Responsive error: mode [" + mode + "] not found" );
    return UI.responsive.defs.css[mode];
  },
  hasmode: function( id, mode ) {
    return UI.hasclass( id, UI.responsive.mode2class(mode) );
  },
  remmode: function( id, idcontainer, mode ) {
    UI.remclass( id, UI.responsive.mode2class(mode) );
    UI.remclass( UI.getcontainer(id,idcontainer), UI.responsive.mode2class(mode) );
  },
  addmode: function( id, idcontainer, mode ) {
    UI.addclass( id, UI.responsive.mode2class(mode) );
    UI.addclass( UI.getcontainer(id,idcontainer), UI.responsive.mode2class(mode) );
  },
  replacemodes: function( id, idcontainer, modes1, modes2 ) {
    var i;
    for( i=0; i<modes1.length; i++ )
      UI.responsive.remmode( id, idcontainer, modes1[i] );
    for( i=0; i<modes2.length; i++ )
      UI.responsive.addmode( id, idcontainer, modes2[i] );
  },
  setmanipview: function( id, idcontainer ) {
    if (UI.responsive.hasmode( id, 'manip' ))
      UI.manipulation.delete( id );
    UI.responsive.replacemodes( id, idcontainer, ['resize'], ['manip'] );
    return UI.manipulation.create( id );
  },
  setresizeview: function( id, idcontainer ) {
    if (!UI.responsive.hasmode( id, 'resize' )) {
      UI.responsive.replacemodes( id, idcontainer, ['manip'], ['resize'] );
      return UI.manipulation.delete( id );
    }
  },
  resize: function( id, idcontainer, init ) {
    function set( e, cont ) {
      UI.responsive.setmodes( e, cont );
      if (UI.responsive.hasmode( e, 'manip' )) {
        if (init)
          UI.manipulation.create( id );
        else {
          var m = UI.manipulation.getmanipulator( id );
          if (m)
            m.resize( id, cont );
        }
      }
    }
    if (id)
      set( id, idcontainer );
    else
      UI.responsive.processelems( set );
  },
  init: function( id, idcontainer ) {
    UI.responsive.resize( id, idcontainer, true );
  },
  debugshowdims: function( id ) {
    var e = UI.el( id );
    var dims = {
      'client':  {'wid':e.clientWidth, 'hgt':e.clientHeight},
      'manip':   {'wid':e.scrollWidth, 'hgt':e.scrollHeight},
      'wid,hgt': {'wid':e.width, 'hgt':e.height}
    };
    console.log( "DIMS: " + JSON.stringify(dims) );
  },
  setmodes: function( id, idcontainer ) {
    UI.responsive.replacemodes( id, idcontainer, 
                                UI.responsive.defs.szmodes, UI.responsive.getmodes(id,idcontainer) );
  },
  getmodes: function( id, idcontainer ) {
    return UI.view.characterize( id, UI.getcontainer(id,idcontainer) );
  }
};


/*
 * elem view helpers
 */
UI.view = {
  scroll: function( id, delta, idcontainer ) {
    idcontainer = UI.getcontainer( id, idcontainer );
    var e = UI.el( idcontainer );
    e.scrollLeft -= delta.x;
    e.scrollTop -= delta.y;
  },
  center: function( id, scale, idcontainer ) {
    idcontainer = UI.getcontainer( id, idcontainer );
    var ed = UI.view.evp( id, idcontainer );
    var cd = UI.view.cvp( idcontainer );
    scale = scale ? scale : 1.0;
    var origin = {y: (cd.hgt - (ed.hgt*scale)) / 2, x: (cd.wid - (ed.wid*scale)) / 2};
    UI.transform.css.zoomnew( id, {x:scale, y:scale}, origin );
  },
  centerfit: function( id, adjust, idcontainer ) {
    idcontainer = UI.getcontainer( id, idcontainer );
    var ed = UI.view.evp( id, idcontainer );
    var cd = UI.view.cvp( idcontainer );
    var v = UI.view.characterize( id, idcontainer );
    var scale = 1.0, origin = {x:0, y:0};
    if (v.indexOf( 'small' ) >= 0)
      origin.y = (cd.hgt - ed.hgt) / 2, origin.x = (cd.wid - ed.wid) / 2;
    else
      if (v.indexOf( 'aspectwide' ) >= 0)
        scale = cd.wid / ed.wid, origin.y = (cd.hgt - (ed.hgt * scale)) / 2;
      else
        if (v.indexOf( 'aspecttall' ) >= 0)
          scale = cd.hgt / ed.hgt, origin.x = (cd.wid - (ed.wid * scale)) / 2;
    if (adjust) {
      if (cd.wid <= cd.hgt && adjust.portrait) {
        if (adjust.portrait.position == 'top')
          origin.y = 0;
        if (adjust.portrait.tweak)
          if (v.indexOf( 'high' ) >= 0)
            origin.y += cd.hgt * (adjust.portrait.tweak.high ? adjust.portrait.tweak.high : 0);
          else
            if (v.indexOf( 'medhigh' ) >= 0)
              origin.y += cd.hgt * (adjust.portrait.tweak.medhigh ? adjust.portrait.tweak.medhigh : 0);
            else
              if (v.indexOf( 'short' ) >= 0)
                origin.y += cd.hgt * (adjust.portrait.tweak.short ? adjust.portrait.tweak.short : 0);
              else
                if (v.indexOf( 'dwarf' ) >= 0)
                  origin.y += cd.hgt * (adjust.portrait.tweak.dwarf ? adjust.portrait.tweak.dwarf : 0);

        /*
        if (adjust.portrait.position == 'bottom')
          origin.y = cd.hgt - (ed.hgt * scale);
        if (adjust.portrait.tweak && v.indexOf( 'small' ) >= 0  && ed.hgt < (cd.hgt/3.5))
          origin.y += cd.hgt * adjust.portrait.tweak;
        */
      }
      if (cd.wid > cd.hgt && adjust.landscape) {
        if (adjust.landscape.position == 'left')
          origin.x = 0;
        if (adjust.landscape.position == 'right')
          origin.x = cd.wid - (ed.wid * scale);
      }
    }
    UI.transform.css.zoomnew( id, {x:scale, y:scale}, origin );
  },
  evp: function( id ) {
    var e = UI.el( id );
    var vp = {wid: (e && e.clientWidth) ? e.clientWidth : window.innerWidth,
              hgt: (e && e.clientHeight) ? e.clientHeight : window.innerHeight};
    if ((e instanceof HTMLImageElement) && e.naturalWidth)
      vp = {wid: e.naturalWidth, hgt: e.naturalHeight};
    else
      if (e.width)
        vp = {wid: e.width, hgt: e.height};
    return vp;
  },
  cvp: function( id ) {
    var e = UI.el( id );
    var vp = {wid: (e && e.clientWidth) ? e.clientWidth : window.innerWidth,
              hgt: (e && e.clientHeight) ? e.clientHeight : window.innerHeight};
    return vp;
  },
  characterize: function( id, idcontainer ) {
    idcontainer = UI.getcontainer( id, idcontainer );
    var ed = UI.view.evp( id, idcontainer );
    var cd = UI.view.cvp( idcontainer );
    //console.log( "view: ed:" + JSON.stringify(ed) + ", cd:" + JSON.stringify(cd) );
    var modes = [];
    function addmode( m ) {modes.push( m );}
    function aspect() {
      var asp = {e: ed.wid / ed.hgt, c: cd.wid / cd.hgt};
      if (asp.e < asp.c)
        addmode( 'aspecttall' );
      else
        addmode( 'aspectwide' );
      return asp;
    }
    aspect();
    var eh = ed.hgt;
    if (ed.wid <= cd.wid && ed.hgt <= cd.hgt)
      addmode( 'small' );
    else
      eh = ed.hgt * (cd.wid / ed.wid);
    if (cd.hgt > (eh*3.4))
      addmode( 'dwarf' );
    else
      if (cd.hgt > (eh*2.7))
        addmode( 'short' );
      else
        if (cd.hgt > (eh*2.2))
          addmode( 'medhigh' );
        else
          if (cd.hgt > (eh*1.7))
            addmode( 'high' );
    if (ed.wid > cd.wid)
      addmode( 'wide' );
    if (ed.hgt > cd.hgt)
      addmode( 'tall' );
    return modes;
  }
}


/*
 * elem classlist helpers
 */
UI.class = { 
  has: function( id, cls ) {
    var e = UI.el( id );
    return (e && cls && e.classList.contains( cls ));
  },
  swap: function( id, cls1, cls2 ) {
    var e = UI.el( id );
    if (e)
      if (e.classList.contains( cls1 ))
        UI.replaceclass( id, cls1, cls2 );
      else
        if (e.classList.contains( cls2 ))
          UI.replaceclass( id, cls2, cls1 );
        else
          e.classList.add( cls2 );
  },
  rem: function( id, cls ) {
    var e = UI.el( id );
    if (e && cls)
      if (e.classList.contains( cls ))
        e.classList.remove( cls );
  },
  add: function( id, cls ) {
    var e = UI.el( id );
    if (e && cls)
      if (!e.classList.contains( cls ))
        e.classList.add( cls );
  },
  toggle: function( id, cls, toggle ) {
    if (toggle)
      UI.addclass( id, cls );
    else
      UI.remclass( id, cls );
    return toggle ? false : true;
  },
  replace: function( id, cls1, cls2 ) {
    var e = UI.el( id );
    if (e) {
      UI.remclass( e, cls1 );
      UI.addclass( e, cls2 );
    }
  },
  replaces: function( id, clslistrem, clslistadd ) {
    var i;
    for( i=0; i<clslistrem.length; i++ )
      UI.remclass( id, clslistrem[i] );
    for( i=0; i<clslistadd.length; i++ )
      UI.addclass( id, clslistadd[i] );
  },
  process: function( cls, processor ) {
    var elems = document.getElementsByClassName( cls );
    for( var i=0; i<elems.length; i++ )
      processor( elems[i] );
    return elems.length;
  }
};
/*expose legacy names*/
UI.hasclass = UI.class.has,
UI.swapclass = UI.class.swap,
UI.remclass = UI.class.rem,
UI.addclass = UI.class.add,
UI.replaceclass = UI.class.replace,
UI.replaceclasses = UI.class.replaces,
UI.processelems = UI.class.process;


/*
 * UI basic helpers
 *   'id': string or HTMLElement
 */
UI.util = {
  el: function( id ) {
    var e = null;
    if (id)
      if (id instanceof HTMLElement)
        e = id;
      else
        e = document.getElementById( id );
    return e;
  },
  getparent: function( id ) {
    var e = UI.el( id );
    return (e && e.parentElement) ? e.parentElement : null;
  },
  getcontainer: function( id, idcontainer ) {
    return idcontainer ? idcontainer : UI.getparent( id );
  },
  setstyle: function( id, s, v ) {
    var e = UI.el( id );
    if (e) e.style[s] = v;
  },
  remstyle: function( id, s ) {
    var e = UI.el( id );
    if (e) e.style.removeProperty( s );
  },
  style: function( id, prop ) {
    var e = UI.el( id );
    if (!e) return;
    return window.getComputedStyle( e ).getPropertyValue( prop );
  },
  swapstyle: function( id1, id2, prop, iseq ) {
    var e1 = UI.el( id1 );
    var e2 = UI.el( id2 );
    if (e1 && e2) {
      var s1 = UI.style( e1, prop );
      var s2 = UI.style( e2, prop );
      if (s1 || s2)
        if (!iseq || s1 == iseq)
          UI.setstyle( e1, prop, s2 ),
          UI.setstyle( e2, prop, s1 );
    }
  },
  ischk: function( id, def ) {
    var e = UI.el( id );
    if (!e) return def;
    return e.checked;
  },
  chk: function( id, v ) {
    var e = UI.el( id );
    e.checked = v;
  },
  en: function( id, on ) {
    var e = UI.el( id );
    e.disabled = !on;
  },
  clipnum: function( n, min, max ) {
    n = isFinite(n) ? n : 0;
    if (min != undefined)
      n = n < min ? min : n;
    if (max != undefined)
      n = n > max ? max : n;
    return n;
  },
  v: function( id, def ) {
    var e = UI.el( id );
    if (!e) return def;
    if (!e.value && def) return def+"";
    return e.value;
  },
  putv: function( id, vn ) {
    var e = UI.el( id );
    if (e) e.value = vn;
  },
  puts: function( id, s ) {
    var e = UI.el( id );
    if (e) e.innerHTML = s ? s : "";
  },
  gets: function( id ) {
    var e = UI.el( id );
    return e ? e.innerHTML : "";
  },
  putin: function( id, i ) {
    UI.puts( id, i, i?i.toString():"" );
  },
  num: function( id, min, max, def ) {
    var n = parseFloat( UI.v(id,def) );
    n = UI.clipnum( n, min, max );
    UI.putv( id, n );
    return n;
  },
  int: function( id, min, max, def ) {
    var n = parseInt( UI.v(id,def) );
    n = UI.clipnum( n, min, max );
    UI.putv( id, n );
    return n;
  },
  show: function( id, show ) {
    UI.setstyle( id, 'display', show?'block':'none' );
  },
  showinline: function( id, show ) {
    UI.setstyle( id, 'display', show?'inline-block':'none' );
  },
  unfold: function( idunfoldbtn, idfoldbtn, idfoldpane, scrollto ) {
    UI.setstyle( idunfoldbtn, 'display', 'none' );
    UI.setstyle( idfoldbtn, 'display', 'inline-block' );
    UI.replaceclass( idfoldpane, 'closed', 'opened' );
    if (scrollto)
      UI.el(idfoldpane).scrollIntoView( {behavior: "smooth"} );
  },
  fold: function( idunfoldbtn, idfoldbtn, idfoldpane ) {
    UI.setstyle( idunfoldbtn, 'display', 'inline-block' );
    UI.setstyle( idfoldbtn, 'display', 'none' );
    UI.replaceclass( idfoldpane, 'opened', 'closed' );
  },
  toggle: function( id1, id2 ) {
    UI.swapclass( id1, 'hidden', 'visible' );
    UI.swapclass( id2, 'visible', 'hidden' );
  },
  togglemenu: function( idmenu, idpane ) {
    UI.swapclass( idmenu, 'disabled', 'enabled' );
    UI.swapclass( idpane, 'visible', 'hidden' );
  },
  toggleall: function( id1, ids2 ) {
    UI.swapclass( id1, 'hidden', 'visible' );
    for( var i=0; i<ids2.length; i++ )
      UI.swapclass( ids2[i], 'visible', 'hidden' );
  },
  devicecanhover: function() {
    return (!window.matchMedia( "(hover: none)" ).matches);
  },
  haspointers: function( el ) {
    return true; //return ('onpointerdown' in el);
  }
};
/*expose legacy names*/
for( const p in UI.util)
  UI[p] = UI.util[p];


/*
 * img helpers
 */
UI.img = {
  drawimgoncanv: function( idcanv, img, x, y ) {
    var ce = UI.el( idcanv );
    ce.width = img.width, ce.height = img.height;
    var cxt = ce.getContext( '2d' );
    cxt.drawImage( img, x?x:0, y?y:0 );
  },
  loadurl: function( url, name, callbacks ) {
    var name = name ? name : ((url.slice(0,5) == 'data:') ? "" : url);
    var img = new Image();
    img.onerror = function() {
      callbacks.onerror( 'ERROR: image '+name+' not found, could not be loaded, or is not valid', name );
    }
    img.onload = function() {
      callbacks.onloaded( img, name );
    }
    try {
      img.src = url;
    }
    catch( e ) {
      callbacks.onloaderror( "ERROR: js error attempting to load img " + name, name );
    }
  },
  loadcanvimg: function( idcanv, url, name, callbacks ) {
    function err( msg, n ) {
      if (callbacks && callbacks.onnotify)
        callbacks.onnotify( idcanv, msg, url, n );
    }
    function setimg( img, n ) {
      UI.drawcanvimg( idcanv, img );
      if (callbacks && callbacks.onloaded)
        callbacks.onloaded( idcanv, img, url, n );
    }
    var _callbacks = {
      onloaded: function( img, n ) {setimg( img, n );},
      onerror: function( msg, n ) {err( msg, n );}
    }
    UI.loadimgurl( url, name, _callbacks );
  }
};


/*
 * utils
 */
var Util = {
  copy: function( data ) {
    var res = JSON.stringify( data );
    return JSON.parse( res );
  }
};
    </script>

<!--    <script src="../imageprocui.js"></script>  -->
    <script>
/*
 *  Widgets for image viewer/processor, 2022 Greg Sidal, MIT licence
 *    requires {lib}/imageproc.js, {lib}/uiutil.js
 *
 *  UI.ImageViewer:     viewer with manipulation (panning, zooming)
 *  UI.ImageProcessor:  UI.ImageViewer with image data processing
 */


/*
 *  Image viewer
 */
UI.ImageViewer = {
  def: {
    /* ID names: wgtid + def.id[sfx] */
    sfx: {
      /* required canvas or image (container is immediate parent) */
      canv:       '_canv',

      /* optional */
      stats:      '_stats',         //file name
      title:      '_subtitle',      //file name
      size:       '_size',          //img size
      file:       '_file',          //open file "button"
      save:       '_save',          //save file "button"
      savefn:     '_savefilename',  //input box for save file name

      /* optional sections reflecting states (css class names 'opened' or 'closed' applied) */
      manip:      '_manip',         /*when image is UI.responsive.ismanipview*/
      fit:        '_fitbtn',        /*when image is Manipulator.fitted*/
      actual:     '_actualbtn',     /*when image is Manipulator.actual (1px==1devicepx)*/
      isopen:     '_isimgopen',     /*when image is open*/
      wait:       '_wait',          /*when large image is processing*/
      saveable:   '_savectrls',     /*when image is changed*/
    },
    id: {
      mk:         function( pfx, sfx ) {return pfx + (UI.ImageViewer.def.sfx[sfx] ? UI.ImageViewer.def.sfx[sfx] : '');},
      el:         function( pfx, sfx ) {return UI.el( UI.ImageViewer.def.id.mk(pfx,sfx) );}
    },
    css: {
      default:    'stretch',
      get:        function( n ) {return (UI.ImageViewer.def.css[n] ? UI.ImageViewer.def.css[n] : '');}
    }
  },
  views: [],
  forcedisallowcanvasdata: false     //true: simulate Tor Browser for testing
};
UI.ImageViewer.init = function( wgtid, params ) {
  params = params ? params : {};
  var initviewresize = UI.responsive.isresizeview( UI.ImageViewer.def.id.el(wgtid,'canv') );
  /*
  var params = {src: {url: srcu}, 
                dim: {wid: 0, hgt: 0},
                name: srcname, 
                setinitviewfromcss: false, 
                callbacks: {open: opencallback, resize: resizecallback}, 
                CanvasImageFile: CanvasImage.File, 
                metadata: {} };
  */
  function notify( msg ) {
    if (UI.ImageViewer.views[wgtid].cif)
      if (msg) {
        if (msg.slice(0,6) == 'ERROR:')
          alert( msg );
        else
          UI.ImageViewer.views[wgtid].filename = msg;
      }
      else {
        if (!UI.ImageViewer.views[wgtid].open)
          UI.remclass( UI.ImageViewer.def.id.mk(wgtid,'canv'), UI.ImageViewer.def.css.get('default') );
        UI.ImageViewer.views[wgtid].open=true, UI.ImageViewer.views[wgtid].default++;
        if (params.setinitviewfromcss && initviewresize)
          UI.ImageViewer.setresizeview( wgtid );
        else
          UI.ImageViewer.setmanipview( wgtid );
        UI.ImageViewer.setupctrls( wgtid, false );
        UI.ImageViewer.views[wgtid].opencallback( wgtid );
      }
  }
  UI.ImageViewer.views[wgtid] = {open: false,
                    default: 0, 
                    opencallback: (params.callbacks && params.callbacks.open) ? params.callbacks.open : function(){}, 
                    resizecallback: (params.callbacks && params.callbacks.resize) ? params.callbacks.resize : function(){}, 
                    filename: "", 
                    metadata: params.metadata};
  if (params.CanvasImageFile)
    UI.ImageViewer.views[wgtid].cif = new params.CanvasImageFile( UI.ImageViewer.def.id.el(wgtid,'canv'), notify );
  else
    UI.ImageViewer.views[wgtid].cif = new CanvasImage.File( UI.ImageViewer.def.id.el(wgtid,'canv'), notify );
  if (params.src.url)
    UI.ImageViewer.setsrc( wgtid, null, params.src.url );
  else
    UI.ImageViewer.views[wgtid].default = 1;
  if (params.dim)
    UI.ImageViewer.views[wgtid].cif.getcanvasimageobj().setsize( params.dim.wid, params.dim.hgt );
  if (!params.src.url)
    UI.ImageViewer.resizeid( wgtid, true );
}
UI.ImageViewer.setsrc = function( wgtid, f, u ) {
  if (UI.ImageViewer.views[wgtid] && UI.ImageViewer.views[wgtid].cif)
    if (f || u)
      UI.ImageViewer.views[wgtid].cif.getcanvasimagefileobj().setsrc( f, u );
}
UI.ImageViewer.clickopen = function( wgtid ) {
  if (UI.ImageViewer.testcanvas( wgtid ))
    UI.ImageViewer.def.id.el( wgtid, 'file' ).click();
}
UI.ImageViewer.ismanipview = function( wgtid ) {
  return UI.responsive.ismanipview( UI.ImageViewer.def.id.mk(wgtid,'canv') );
}
UI.ImageViewer.isfitted = function( wgtid ) {
  var m = UI.manipulation.getmanipulator( UI.ImageViewer.def.id.mk(wgtid,'canv') );
  return m ? m.getstates().fitted : false;
}
UI.ImageViewer.isactual = function( wgtid ) {
  var m = UI.manipulation.getmanipulator( UI.ImageViewer.def.id.mk(wgtid,'canv') );
  return m ? m.getstates().actualsize : false;
}
UI.ImageViewer.isopen = function( wgtid ) {
  return (UI.ImageViewer.views[wgtid] && UI.ImageViewer.views[wgtid].open);
}
UI.ImageViewer.clickback = function( wgtid ) {
  if (UI.ImageViewer.isopen( wgtid ))
    return false;
  UI.ImageViewer.clickopen( wgtid );
  return true;
}
UI.ImageViewer.onmanipstatechg = function( wgtid, states ) {
  if (wgtid instanceof HTMLElement)
    wgtid = wgtid.id.split('_')[0];
  UI.ImageViewer.opensection( wgtid, 'fit', !states.fitted );
  UI.ImageViewer.opensection( wgtid, 'actual', !states.actualsize );
}
UI.ImageViewer.resizeid = function( wgtid, init ) {
  if (wgtid instanceof HTMLElement)
    wgtid = wgtid.id.split('_')[0];
  if (!UI.ImageViewer.views[wgtid])
    throw( "No ImageViewer has been created for Id '" + wgtid + "' (call UI.ImageViewer.init)" );
  var canv = UI.el( UI.ImageViewer.def.id.mk(wgtid,'canv') );
  UI.responsive.resize( canv, null, init );
  var m = UI.manipulation.getmanipulator( canv );
  if (!m)
    return;
  m.setstatechangelistener( UI.ImageViewer.onmanipstatechg );
  UI.ImageViewer.views[wgtid].resizecallback( wgtid );
}
UI.ImageViewer.resize = function( wgtid ) {
  if (wgtid)
    UI.ImageViewer.resizeid( wgtid );
  else
    UI.responsive.processelems( UI.ImageViewer.resizeid );
}
UI.ImageViewer.setmanipstate = function( wgtid, vw ) {
  if (UI.ImageViewer.views[wgtid] && UI.ImageViewer.views[wgtid].cif) {
    var m = UI.manipulation.getmanipulator( UI.ImageViewer.def.id.mk(wgtid,'canv') );
    if (m)
      m.reset( vw );
  }
}
UI.ImageViewer.setresizeview = function( wgtid ) {
  if (UI.ImageViewer.views[wgtid] && UI.ImageViewer.views[wgtid].cif) {
    if (UI.responsive.setresizeview( UI.ImageViewer.def.id.mk(wgtid,'canv') ))
      UI.ImageViewer.opensection( wgtid, 'manip', false );
    return UI.ImageViewer.resize( wgtid );
  }
}
UI.ImageViewer.setmanipview = function( wgtid ) {
  if (UI.ImageViewer.views[wgtid] && UI.ImageViewer.views[wgtid].cif) {
    if (UI.responsive.setmanipview( UI.ImageViewer.def.id.mk(wgtid,'canv') ))
      UI.ImageViewer.opensection( wgtid, 'manip', true );
    return UI.ImageViewer.resize( wgtid );
  }
}
UI.ImageViewer.toggleview = function( wgtid ) {
  if (UI.ImageViewer.views[wgtid] && UI.ImageViewer.views[wgtid].cif)
    if (UI.responsive.ismanipview( UI.ImageViewer.def.id.mk(wgtid,'canv') ))
      UI.ImageViewer.setresizeview( wgtid );
    else
      UI.ImageViewer.setmanipview( wgtid );
}
UI.ImageViewer.save = function( wgtid ) {
  if (UI.ImageViewer.views[wgtid] && UI.ImageViewer.views[wgtid].cif)
    if (UI.ImageViewer.views[wgtid].default <= 1)
      alert( "Demo image can not be saved (Chrome security policy).  Images opened locally can be saved locally." );
    else {
      var url = UI.ImageViewer.views[wgtid].cif.getcanvasimagefileobj().getBmpDataUrl();
      UI.ImageViewer.def.id.el(wgtid,'save').href = url;
      UI.ImageViewer.def.id.el(wgtid,'save').download = UI.v( UI.ImageViewer.def.id.mk(wgtid,'savefn'), wgtid+".png" );
      UI.ImageViewer.def.id.el(wgtid,'save').click();
    }
}
UI.ImageViewer.opensection = function( wgtid, sfx, op ) {
  var f = UI.ImageViewer.def.id.mk( wgtid, sfx );
  if (op)
    UI.replaceclass( f, 'closed', 'opened' );
  else
    UI.replaceclass( f, 'opened', 'closed' );
}
UI.ImageViewer.showwait = function( wgtid, show ) {
  //UI.ImageViewer.opensection( wgtid, 'wait', show );
  UI.show( UI.ImageViewer.def.id.mk(wgtid,'wait'), show );
}
UI.ImageViewer.setupctrls = function( wgtid, ismod ) {
  UI.ImageViewer.showwait( wgtid, false );
  UI.ImageViewer.opensection( wgtid, 'isopen', true );
  UI.ImageViewer.opensection( wgtid, 'saveable', ismod );
  var canv = UI.el( UI.ImageViewer.def.id.mk(wgtid,'canv') );
  if (canv && UI.ImageViewer.views[wgtid] && UI.ImageViewer.views[wgtid].filename) {
    UI.puts( UI.ImageViewer.def.id.mk(wgtid,'title'), UI.ImageViewer.views[wgtid].filename );
    UI.puts( UI.ImageViewer.def.id.mk(wgtid,'stats'), UI.ImageViewer.views[wgtid].filename );
    UI.puts( UI.ImageViewer.def.id.mk(wgtid,'size'), canv.width + "x" + canv.height );
  }
  else {
    UI.puts( UI.ImageViewer.def.id.mk(wgtid,'title'), "" );
    UI.puts( UI.ImageViewer.def.id.mk(wgtid,'stats'), "" );
    UI.puts( UI.ImageViewer.def.id.mk(wgtid,'size'), "" );
  }
  //UI.showinline( UI.ImageViewer.def.id.mk(wgtid,'manip'), true );
}
UI.ImageViewer.waitdo = function( wgtid, dofunstr ) {
  if (UI.ImageViewer.views[wgtid] && UI.ImageViewer.views[wgtid].cif) {
    UI.ImageViewer.showwait( wgtid, true );
    setTimeout( dofunstr, 100 );
  }
}


/*
UI.ImageProcessor  Image data processing on canvas
*/
UI.ImageProcessor = UI.ImageViewer;
UI.ImageProcessor.def.sfx.oplist = '_oplist';
UI.ImageProcessor.waitsize = 3900000;   //show wait prompt when image larger than this
UI.ImageProcessor.setup = function( wgtid, srcu, srcname, opencallback, resizecallback ) {
  function onopen( wgtid ) {
    if (UI.ImageViewer.views[wgtid].cif) {
      UI.ImageViewer.views[wgtid].processor.ops = [];
      UI.ImageProcessor.pushop( wgtid, 'open' );
      UI.ImageProcessor.views[wgtid].metadata.opencallback( wgtid );
    }
  }
  var params = {src: {url: srcu}, 
                name: srcname, 
                callbacks: {open: onopen, resize: resizecallback}, 
                CanvasImageFile: CanvasImage.File.Data,
                metadata: {'opencallback':opencallback?opencallback:function(){}} };
  UI.ImageViewer.init( wgtid, params );
  UI.ImageViewer.views[wgtid].processor = {maxops:1000, ops:[]};
}
UI.ImageProcessor.setmaxops = function( wgtid, maxops ) {
  UI.ImageViewer.views[wgtid].processor.maxops = maxops;
}
UI.ImageProcessor.decorateop = function( opname ) {
  var op = opname.slice( 0, opname.length-1 );
  return "<div class='text icon " + op + "'>" + opname + "</div>";
}
UI.ImageProcessor.showops = function( wgtid ) {
  var sfx = "", oplist = "";
  for( var i=1; i<UI.ImageProcessor.views[wgtid].processor.ops.length; i++ ) {
    sfx += "-" + UI.ImageProcessor.views[wgtid].processor.ops[i].opname;
    oplist += UI.ImageProcessor.decorateop( UI.ImageProcessor.views[wgtid].processor.ops[i].opname );
  }
  if (oplist) UI.puts( UI.ImageViewer.def.id.mk(wgtid,'oplist'), oplist );
  UI.putv( UI.ImageViewer.def.id.mk(wgtid,'savefn'), UI.ImageViewer.views[wgtid].filename.split('.')[0] + sfx  + ".png" );
  UI.ImageViewer.setupctrls( wgtid, sfx );
}
UI.ImageProcessor.pushop = function( wgtid, op ) {
  if (op && UI.ImageProcessor.views[wgtid].processor.ops.length < UI.ImageViewer.views[wgtid].processor.maxops) {
    UI.ImageProcessor.views[wgtid].processor.ops.push( 
                 {opname: op, undoimg: UI.ImageViewer.views[wgtid].cif.getcanvasimagedataobj().getviewdata()} );
    UI.ImageProcessor.showops( wgtid );
  }
}
UI.ImageProcessor.popops = function( wgtid, num ) {
  var ops = UI.ImageProcessor.views[wgtid].processor.ops;
  if (!num || num > (ops.length-1))
    num = ops.length - 1;
  var i, fin = ops.length-num;
  for( i=ops.length-1; i>=fin; i-- )
    ops.pop();
  UI.ImageViewer.views[wgtid].cif.getcanvasimagedataobj().setdata( ops[i].undoimg );
  UI.ImageProcessor.showops( wgtid );
}
UI.ImageProcessor.undo = function( wgtid, num ) {
  if (UI.ImageViewer.views[wgtid].cif && UI.ImageViewer.views[wgtid].processor)
    UI.ImageProcessor.popops( wgtid, num );
}
UI.ImageProcessor.op = function( wgtid, fun, opname, includealpha ) {
  UI.ImageViewer.wait( wgtid, fun, opname, includealpha );
}
UI.ImageProcessor.wait = function( wgtid, actfun, opname, includealpha ) {
  if (UI.ImageViewer.views[wgtid] && UI.ImageViewer.views[wgtid].cif) {
    if (!UI.ImageViewer.testcanvas( wgtid ))
      return;
    var sz = UI.ImageViewer.views[wgtid].cif.getcanvasimageobj().getsize();
    if ((sz.wid*sz.hgt) > UI.ImageProcessor.waitsize)
      UI.ImageViewer.showwait( wgtid, true );
    var fs = "UI.ImageProcessor.process('" + wgtid + "'," + actfun + ",'" + opname + "'," + (includealpha?'true':'false') + ")";
    setTimeout( fs, 50 );
  }
}
UI.ImageProcessor.opcompleted = function( wgtid, opname ) {
  UI.ImageProcessor.pushop( wgtid, opname );
}
UI.ImageProcessor.process = function( wgtid, processor, opname, includealpha ) {
  if (UI.ImageViewer.views[wgtid] && UI.ImageViewer.views[wgtid].cif) {
    var res;
    if (includealpha)
      res = UI.ImageViewer.views[wgtid].cif.getcanvasimagedataobj().processrgba( processor, {'wgtid':wgtid,'opname':opname} );
    else
      res = UI.ImageViewer.views[wgtid].cif.getcanvasimagedataobj().processrgb( processor, {'wgtid':wgtid,'opname':opname} );
    if (res)
      UI.ImageProcessor.opcompleted( wgtid, opname );
  }
}
UI.ImageProcessor.togglecanvasdata = function() {UI.ImageProcessor.forcedisallowcanvasdata = !UI.ImageProcessor.forcedisallowcanvasdata;}
UI.ImageProcessor.canvasdatamsg = 
'Web browser is blocking use of canvas data. \n\n' +
'Some privacy-oriented browsers such as Tor do this by default to prevent an ' + 
'exploit used by surveillance (ad) networks to uniquely identify users. ' + 
'Browser may have a setting that allows canvas data.';
UI.ImageProcessor.testcanvas = function( wgtid ) {
  var ret = CanvasImage.Image.Data.Util.test( UI.ImageProcessor.forcedisallowcanvasdata );
  if (ret == 'nocanvdata')
    alert( UI.ImageProcessor.canvasdatamsg );
  if (ret == 'nocanv')
    alert( "Browser lacks support for canvas" );
  return !ret;
}
var IPUI = UI.ImageProcessor;
    </script>

<!--    <script src="dip.js"></script>  -->
    <script>
/*
 *  "Digital Image Processing" Editor, 2022-2023 Greg Sidal, MIT licence
 *  requires {lib}/imageproc.js, {lib}/uiutil.js, imageprocui.js
 */


/*
 *  UI main, uses UI.ImageProcessor widget
 */
var DIP = {debug: false, debugmsg: function(msg) {if (DIP.debug) console.log(msg);} };
DIP.setup = function( wgtid, srcu, srcname ) {
  function onresize( wgtid ) {
    //var toosmall = UI.responsive.hasmode( IPUI.def.id.mk(wgtid,'canv'), 'small' );
    //UI.showinline( IPUI.def.id.mk(wgtid,'zoom'), !toosmall && IPUI.isopen(wgtid) );
  }
  IPUI.setup( wgtid, srcu, srcname, null, onresize );
}
DIP.togglemenu = function( menuid, paneid ) {
}
DIP.clickback = function( wgtid, x, y ) {
  if (!IPUI.clickback( wgtid )) {
    var cid  = IPUI.def.id.mk( wgtid, 'canv' );
    if (document.elementFromPoint( x, y ) != UI.el(cid))
      UI.togglemenu( 'menubar', 'controlpane' );
  }
}
DIP.clickbackevent = function( event ) {
  return DIP.clickback( 'dip', event.pageX, event.pageY );
}

DIP.clickopen = IPUI.clickopen;
DIP.togglecanvasdata = IPUI.togglecanvasdata;
UI.ImageProcessor.canvasdatamsg += 
'\n\nAlternatively, the offline version of this page can be run locally. ' + 
"Select 'Self-contained downloadable' to download, then open HTML file " + 
"from prompt or from downloads folder using device's file manager.";
//UI.ImageProcessor.forcedisallowcanvasdata = true;
DIP.setsrc = IPUI.setsrc;
DIP.resize = IPUI.resize;
DIP.setview = IPUI.setview;
DIP.toggleview = IPUI.toggleview;
DIP.undo = IPUI.undo;
DIP.save = IPUI.save;
DIP.setupctrls = IPUI.setupctrls;
DIP.super_decorateop = UI.ImageProcessor.decorateop;
UI.ImageProcessor.decorateop = function( opname ) {
  /*
  .text.icon.r:after {content: '  \25B8 ' ;}
  .text.icon.l:before {content: '\25C2  ' ;}
  .text.icon.sw:before {content: ' \21C4  ' ;} 
  .text.icon.xo:before {content: ' \2295  ' ;} 
  .text.icon.a:before {content: ' \2227  ' ;}  
  .text.icon.o:before {content: ' \2228  ' ;}  
  */
  var op = opname.slice( opname.length-1 );
  if (op == "l" || op == "r")
    return "<div class='text icon " + op + "'>" + opname + "</div> ";
  return DIP.super_decorateop( opname );
}


DIP.op = function( wgtid, act ) {
  IPUI.op( wgtid, 'DIP._'+act, act );
}

/* shift ops */
DIP._shr = function( datadescriptor ) {
  var data = datadescriptor.data;
  var len = data.length, ovfl = 0, ovfl2 = 0, cn;
  for( var i=0; i<len; i++ ) {
    cn = data[i];
    ovfl2 = (cn & 0x01) << 7;  //1000 0000
    cn = (cn >> 1) | ovfl;
    ovfl = ovfl2;
    data[i] = cn & 0xff;
  }
  datadescriptor.data = data;
  return datadescriptor;
}
DIP._shl = function( datadescriptor ) {
  var data = datadescriptor.data;
  var len = data.length, ovfl = 0, cn;
  for( var i=len-1; i>=0; i-- ) {
    cn = data[i];
    cn = (cn << 1) | ovfl;
    ovfl = cn > 255;
    data[i] = cn & 0xff;
  }
  datadescriptor.data = data;
  return datadescriptor;
}

/*swap ops*/
DIP._swb = function( datadescriptor ) {
  var data = datadescriptor.data;
  var len = data.length;
  for( var i=0; i<len; i++ )
    for( var j=0,mask=0x01,d; j<8; j+=2,mask<<=2 ) {
//if (i<5) DIP.test_showbinstr( mask, " MASK ============", j, 2 );
      d = ((data[i] & mask) << 1) | ((data[i] & (mask<<1)) >> 1);
//if (i<5) DIP.test_showbinstr( data[i], " byte ", j, 2 );
      data[i] &= ~(mask | mask<<1);
      data[i] |= d;
//if (i<5) DIP.test_showbinstr( data[i], " post op", j, 2 );
    }
  datadescriptor.data = data;
  return datadescriptor;
}
DIP._swn = function( datadescriptor ) {
  var data = datadescriptor.data;
  var len = data.length;
  for( var i=0; i<len; i++ ) {
    data[i] = ((data[i] & 0x0f) << 4) | ((data[i] & 0xf0) >> 4);
  }
  datadescriptor.data = data;
  return datadescriptor;
}
DIP._swy = function( datadescriptor ) {
  var data = datadescriptor.data;
  var len = data.length, cn;
  for( var i=0; i<len; i+=2 ) {
    cn = data[i];
    data[i] = data[i+1];
    data[i+1] = cn;
  }
  datadescriptor.data = data;
  return datadescriptor;
}

/*xor ops*/
DIP._xob = function( datadescriptor ) {
  DIP.debugmsg( "*** XOB ***" );
  var data = datadescriptor.data;
  var len = data.length;
  for( var i=0; i<len; i++ ) {
    if (i<5) DIP.debugmsg( "============BYTE " + i + "===========" );
    var d, mask = 0x01;
    for( var j=0; j<7; j++,mask<<=1 ) {
      if (i<5) DIP.test_showbinstr( mask, "MASK", j, 1 );
      if (i<5) DIP.test_showbinstr( data[i], "op1", j, 1 );
      if (i<5) DIP.test_showbinstr( data[i], "op2", j+1, 1 );
      d = (data[i] & mask) ^ ((data[i] & (mask<<1)) >> 1);
      data[i] &= ~mask;
      data[i] |= d;
      if (i<5) DIP.test_showbinstr( data[i], "post op", j, 1 );
    }
    if ((i+1) < len) {
      if (i<5) DIP.test_showbinstr( 0x80, "MASK", 7, 1 );
      if (i<5) DIP.test_showbinstr( data[i], "op1", 7, 1 );
      if (i<5) DIP.test_showbinstr( data[i+1], "op2 OVFL", 0, 1 );
      d = (data[i] & 0x80) ^ ((data[i+1] & 0x01) << 7);
      data[i] &= ~0x80;
      data[i] |= d;
      if (i<5) DIP.test_showbinstr( data[i], "post op", 7, 1 );
    }
  }
  datadescriptor.data = data;
  return datadescriptor;
}
DIP._xon = function( datadescriptor ) {
  DIP.debugmsg( "*** XON ***" );
  var data = datadescriptor.data;
  var len = data.length;
  for( var i=0, d; i<len; i++ ) {
    if (i<5) DIP.debugmsg( "============BYTE " + i + "===========" );
    if (i<5) DIP.test_showbinstr( data[i], "op1", 0, 4 );
    if (i<5) DIP.test_showbinstr( data[i], "op2", 4, 4 );
    d = (data[i] & 0x0f) ^ ((data[i] & 0xf0) >> 4);
    if ((i+1) < len) {
      if (i<5) DIP.test_showbinstr( data[i], "op1", 4, 4 );
      if (i<5) DIP.test_showbinstr( data[i+1], "op2 ovfl", 0, 4 );
      d |= (data[i] & 0xf0) ^ ((data[i+1] & 0x0f) << 4);
    }
    data[i] = d;
    if (i<5) DIP.test_showbinstr( data[i], "post op" );
  }
  datadescriptor.data = data;
  return datadescriptor;
}
DIP._xoy = function( datadescriptor ) {
  DIP.debugmsg( "*** XOY ***" );
  var data = datadescriptor.data;
  var len = data.length;
  for( var i=0; i<(len-1); i++ ) {
    if (i<5) DIP.debugmsg( "============BYTE " + i + "===========" );
    if (i<5) DIP.test_showbinstr( data[i], "op1" );
    if (i<5) DIP.test_showbinstr( data[i+1], "op2" );
    data[i] = data[i] ^ data[i+1];
    if (i<5) DIP.test_showbinstr( data[i], "post op" );
  }
  datadescriptor.data = data;
  return datadescriptor;
}

/*or ops*/
DIP._ob = function( datadescriptor ) {
  DIP.debugmsg( "*** OB ***" );
  var data = datadescriptor.data;
  var len = data.length;
  for( var i=0; i<len; i++ ) {
    if (i<5) DIP.debugmsg( "============BYTE " + i + "===========" );
    var d, mask = 0x01;
    for( var j=0; j<7; j++,mask<<=1 ) {
      if (i<5) DIP.test_showbinstr( mask, "MASK", j, 1 );
      if (i<5) DIP.test_showbinstr( data[i], "op1", j, 1 );
      if (i<5) DIP.test_showbinstr( data[i], "op2", j+1, 1 );
      d = (data[i] & mask) | ((data[i] & (mask<<1)) >> 1);
      data[i] &= ~mask;
      data[i] |= d;
      if (i<5) DIP.test_showbinstr( data[i], "post op", j, 1 );
    }
    if ((i+1) < len) {
      if (i<5) DIP.test_showbinstr( 0x80, "MASK", 7, 1 );
      if (i<5) DIP.test_showbinstr( data[i], "op1", 7, 1 );
      if (i<5) DIP.test_showbinstr( data[i+1], "op2 ovfl", 0, 1 );
      d = (data[i] & 0x80) | ((data[i+1] & 0x01) << 7);
      data[i] &= ~0x80;
      data[i] |= d;
      if (i<5) DIP.test_showbinstr( data[i], "post op", 7, 1 );
    }
  }
  datadescriptor.data = data;
  return datadescriptor;
}
DIP._on = function( datadescriptor ) {
  DIP.debugmsg( "*** ON ***" );
  var data = datadescriptor.data;
  var len = data.length;
  for( var i=0, d; i<len; i++ ) {
    if (i<5) DIP.debugmsg( "============BYTE " + i + "===========" );
    if (i<5) DIP.test_showbinstr( data[i], "op1", 0, 4 );
    if (i<5) DIP.test_showbinstr( data[i], "op2", 4, 4 );
    d = (data[i] & 0x0f) | ((data[i] & 0xf0) >> 4);
    if ((i+1) < len) {
      if (i<5) DIP.test_showbinstr( data[i], "op1", 4, 4 );
      if (i<5) DIP.test_showbinstr( data[i+1], "op2 ovfl", 0, 4 );
      d |= (data[i] & 0xf0) | ((data[i+1] & 0x0f) << 4);
    }
    data[i] = d;
    if (i<5) DIP.test_showbinstr( data[i], "post op" );
  }
  datadescriptor.data = data;
  return datadescriptor;
}
DIP._oy = function( datadescriptor ) {
  DIP.debugmsg( "*** OY ***" );
  var data = datadescriptor.data;
  var len = data.length;
  for( var i=0; i<(len-1); i++ ) {
    if (i<5) DIP.debugmsg( "============BYTE " + i + "===========" );
    if (i<5) DIP.test_showbinstr( data[i], "op1" );
    if (i<5) DIP.test_showbinstr( data[i+1], "op2" );
    data[i] = data[i] | data[i+1];
    if (i<5) DIP.test_showbinstr( data[i], "post op" );
  }
  datadescriptor.data = data;
  return datadescriptor;
}

/*and ops*/
DIP._ab = function( datadescriptor ) {
  DIP.debugmsg( "*** AB ***" );
  var data = datadescriptor.data;
  var len = data.length;
  for( var i=0; i<len; i++ ) {
    if (i<5) DIP.debugmsg( "============BYTE " + i + "===========" );
    var d, mask = 0x01;
    for( var j=0; j<7; j++,mask<<=1 ) {
      if (i<5) DIP.test_showbinstr( mask, "MASK", j, 1 );
      if (i<5) DIP.test_showbinstr( data[i], "op1", j, 1 );
      if (i<5) DIP.test_showbinstr( data[i], "op2", j+1, 1 );
      d = (data[i] & mask) & ((data[i] & (mask<<1)) >> 1);
      data[i] &= ~mask;
      data[i] |= d;
      if (i<5) DIP.test_showbinstr( data[i], "post op", j, 1 );
    }
    if ((i+1) < len) {
      if (i<5) DIP.test_showbinstr( 0x80, "MASK", 7, 1 );
      if (i<5) DIP.test_showbinstr( data[i], "op1", 7, 1 );
      if (i<5) DIP.test_showbinstr( data[i+1], "op2 ovfl", 0, 1 );
      d = (data[i] & 0x80) & ((data[i+1] & 0x01) << 7);
      data[i] &= ~0x80;
      data[i] |= d;
      if (i<5) DIP.test_showbinstr( data[i], "post op", 7, 1 );
    }
  }
  datadescriptor.data = data;
  return datadescriptor;
}
DIP._an = function( datadescriptor ) {
  DIP.debugmsg( "*** AN ***" );
  var data = datadescriptor.data;
  var len = data.length;
  for( var i=0, d; i<len; i++ ) {
    if (i<5) DIP.debugmsg( "============BYTE " + i + "===========" );
    if (i<5) DIP.test_showbinstr( data[i], "op1", 0, 4 );
    if (i<5) DIP.test_showbinstr( data[i], "op2", 4, 4 );
    d = (data[i] & 0x0f) & ((data[i] & 0xf0) >> 4);
    if ((i+1) < len) {
      if (i<5) DIP.test_showbinstr( data[i], "op1", 4, 4 );
      if (i<5) DIP.test_showbinstr( data[i+1], "op2 ovfl", 0, 4 );
      d |= (data[i] & 0xf0) & ((data[i+1] & 0x0f) << 4);
    }
    data[i] = d;
    if (i<5) DIP.test_showbinstr( data[i], "post op" );
  }
  datadescriptor.data = data;
  return datadescriptor;
}
DIP._ay = function( datadescriptor ) {
  DIP.debugmsg( "*** AY ***" );
  var data = datadescriptor.data;
  var len = data.length;
  for( var i=0; i<(len-1); i++ ) {
    if (i<5) DIP.debugmsg( "============BYTE " + i + "===========" );
    if (i<5) DIP.test_showbinstr( data[i], "op1" );
    if (i<5) DIP.test_showbinstr( data[i+1], "op2" );
    data[i] = data[i] & data[i+1];
    if (i<5) DIP.test_showbinstr( data[i], "post op" );
  }
  datadescriptor.data = data;
  return datadescriptor;
}


/*C ops*/
DIP._xoC = function( datadescriptor, params ) {
  return DIP.opC( datadescriptor, params, 'x' );
}
DIP._oC = function( datadescriptor, params ) {
  return DIP.opC( datadescriptor, params, 'o' );
}
DIP._aC = function( datadescriptor, params ) {
  return DIP.opC( datadescriptor, params, 'a' );
}
IPUI.def.sfx.C = '_C';
DIP.opC = function( datadescriptor, params, op ) {
  var hex =   ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'];
  function hexclean( hs, pad ) {
    function cleanchar( c ) {
      var i = hex.indexOf( c );
      if (i < 0)
        i = hex.indexOf( pad );
      return hex[i];
    }
    hs = hs ? hs.toLowerCase() : "";
    if (hs.length % 2)
      hs += pad;
    var chs = "";
    for( var i=0; i<hs.length; i++ )
      chs += cleanchar( hs[i] );
    return chs;
  }
  function hexstr2bytes( hs ) {
    function hex2byte( c ) {
      return hex.indexOf( c );
    }
    var bytes = new Uint8Array( hs.length/2 );
    for( var i=0; i<bytes.length; i++ )
      bytes[i] = (hex2byte(hs[i*2]) << 4) | hex2byte(hs[(i*2)+1]);
    return bytes;
  }
  DIP.debugmsg( "*** " + op + "C ***" );
  var data = datadescriptor.data;
  var len = data.length;
  var chs = hexclean( UI.v(IPUI.def.id.mk(params.wgtid,'C')), op=='a'?'f':'0' );
  UI.putv( IPUI.def.id.mk(params.wgtid,'C'), chs );
  var C = hexstr2bytes( chs );
  var clen = C.length;
  if (clen)
    for( var i=0, d; i<len; )
      for( var j=0; i<len && j<clen; i++, j++ ) {
        if (i<5) DIP.debugmsg( "============BYTE " + i + "===========" );
        if (i<5) DIP.test_showbinstr( data[i], "d" );
        if (i<5) DIP.test_showbinstr( C[j], "C" );
        if (op == 'x')
          d = data[i] ^ C[j];
        else
          if (op == 'a')
            d = data[i] & C[j];
          else
            d = data[i] | C[j];
        data[i] = d;
        if (i<5) DIP.test_showbinstr( data[i], "d post op" );
      }
  datadescriptor.data = data;
  return datadescriptor;
}


/*test*/
DIP.test_showbinstr = function( byte, msg, highlight, highlightlen ) {
  var binstr = DIP.test_2binstr( byte, highlight, highlightlen );
  DIP.debugmsg( binstr+" "+msg );
  return binstr;
}
DIP.test_2binstr = function( byte, highlight, highlightlen ) {
  var binstr = "";
  for( var j=0,mask=0x01,d; j<8; j++,mask<<=1 )
    binstr = ((byte & mask) ? "1" : "0") + binstr;
  if (highlightlen) {
    var s = 8 - (highlight + highlightlen);
    var e = 8 - highlight;
    var bs = binstr.slice( 0, s ) + "(";
    bs += binstr.slice( s, e ) + ")";
    bs += binstr.slice( e );
    binstr = bs;
  }
  return binstr;
}
    </script>

    <script>
      DIP.defaultname = "(open an image)";
      DIP.defaulturl = "";
      DIP.debug = false;
    </script>
  </head>
  <body class="app" onload="DIP.setup('dip',DIP.defaulturl,DIP.defaultname);" onresize="DIP.resize('dip');">

    <div class="snap">

      <div id="dip_back" class="resp-back bargap bottom" onclick="DIP.clickbackevent(event)">
        <canvas id="dip_canv" width="800" height="1000" class="responsive resp-resize">
          <div class="text title center">NO CANVAS SUPPORT IN BROWSER <br/>
                   Full-featured browser such as Firefox or Chrome required</div>
        </canvas>
      </div>

      <div class="bar bottom">
        <div class="toolbar" id="titlebar">
          <div class="btnbar">
            <div class="btn menu enabled" id="menubar" onclick="UI.togglemenu('menubar','controlpane')"></div>
            <div class="btn toggle noshow fit" id="dip_fitbtn" onclick="UI.ImageViewer.setmanipstate('dip','fit')" 
                 title="view letterbox (drag to pan, ctrl-press to zoom)"></div>
            <div class="btn toggle noshow actualsize" id="dip_actualbtn" onclick="UI.ImageViewer.setmanipstate('dip','actualsize')" 
                 title="view 1 px == 1 device px (drag to pan, ctrl-press to zoom)"></div>
          </div>
          <div class="text info middle" id="dip_size"></div>
          <div class="btnbar">
            <div class="btn openfile" id="dip_openfile" onclick="DIP.clickopen('dip')"></div>
          </div>
          <div class="text info clickable" id="dip_subtitle" onclick="DIP.clickopen('dip')">(open an image)</div>
        </div>
      </div>

    </div>

    <div class="panelwrap popup"><div id="controlpane" class="panel popup"><div class="content popup">

      <div class="pin corner top right">
        <div class="btn icon closex" id="controlbtn" onclick="UI.togglemenu('menubar','controlpane')"></div>
      </div>

      <div class="section head">
        <div class="text title">
          "Digital Image Processing" Editor
        </div>
        <div class="text addendum">
          Apply machine primitives to image raster data
        </div>
      </div>

      <div class="section main line nowrap">
        <div class="btn box sys open" id="dip_openfile" onclick="DIP.clickopen('dip')"></div>
        <input type="file" class="noshow" accept="image/*" id="dip_file" onchange="DIP.setsrc('dip',this.files[0]);"/>
        <div class="text status">
          <div class="text ok truncate clickable" id="dip_stats" onclick="DIP.clickopen('dip')">(open an image)</div>
        </div>
      </div>

      <div class="slider pagehgt closed" id="dip_isimgopen">
        <div class="section main">

          <div class="section subline">
            <div class="btn box sys unfold" id="dip_unfoldbtn"
                           onclick="UI.unfold('dip_unfoldbtn','dip_foldbtn','dip_foldpane',true)"></div>
            <div class="btn box sys noshow fold" id="dip_foldbtn"
                           onclick="UI.fold('dip_unfoldbtn','dip_foldbtn','dip_foldpane')"></div>
            <div class="btn box op fwd" id="dip_shrbtn" onclick="DIP.op('dip','shr')">shr</div>
            <div class="btn box op rev" id="dip_shlbtn" onclick="DIP.op('dip','shl')">shl</div>
          </div>

          <div class="section sub3">
            <div class="btn box op unfold hid"></div>
            <div class="btn box op swap2" id="dip_swbbtn" onclick="DIP.op('dip','swb')">swb</div>
            <div class="btn box op xor" id="dip_xobbtn" onclick="DIP.op('dip','xob')">xob</div>
            <div class="btn box op and" id="dip_abbtn" onclick="DIP.op('dip','ab')">ab</div>
            <div class="btn box op or" id="dip_obbtn" onclick="DIP.op('dip','ob')">ob</div>
          </div>

          <div class="section sub3">
            <div class="btn box op unfold hid"></div>
            <div class="btn box op swap2" id="dip_swnbtn" onclick="DIP.op('dip','swn')">swn</div>
            <div class="btn box op xor" id="dip_xonbtn" onclick="DIP.op('dip','xon')">xon</div>
            <div class="btn box op and" id="dip_anbtn" onclick="DIP.op('dip','an')">an</div>
            <div class="btn box op or" id="dip_onbtn" onclick="DIP.op('dip','on')">on</div>
          </div>

          <div class="section sub3">
            <div class="btn box op unfold hid"></div>
            <div class="btn box op swap2" id="dip_swybtn" onclick="DIP.op('dip','swy')">swy</div>
            <div class="btn box op xor" id="dip_xoybtn" onclick="DIP.op('dip','xoy')">xoy</div>
            <div class="btn box op and" id="dip_aybtn" onclick="DIP.op('dip','ay')">ay</div>
            <div class="btn box op or" id="dip_oybtn" onclick="DIP.op('dip','oy')">oy</div>
          </div>

          <div id="dip_savectrls" class="slider shorthgt closed">
            <div class="section submain">
              <div class="section subline">
                <div class="btn box sys undo" id="dip_undo1btn" onclick="DIP.undo('dip',1)" title="undo"></div>
                <div class="text status ok" id="dip_oplist"></div>
              </div>
<!--
              <div class="section sub3">
                <div class="btn box sys undo" id="dip_undo1btn" onclick="DIP.undo('dip',1)">Undo</div>
                <div class="btn box sys undoall" id="dip_undoallbtn" onclick="DIP.undo('dip')">Undo all</div>
              </div>
-->
              <div class="section sub3 line nowrap">
                <div class="btn box sys savefile" id="dip_savebtn" onclick="DIP.save('dip')" title="save to file"></div>
                                              <a href="" download="dip.png" class="noshow" id="dip_save"></a>
                <input class="inplong trigger" id="dip_savefilename" value="dip.png" placeholder="save file name"></input>
              </div>
            </div>
          </div>

        </div>

        <div id="dip_foldpane" class="slider highhgt closed">
          <div class="section main">
            <div class="">
              <div class="text addendum i">
                     shr: shift bitstream right
                <br/>shl: shift bitstream left
                <br/>
                <br/>swb: swap adjacent bits
                <br/>xob: xor adjacent bits
                <br/>ab: and adjacent bits
                <br/>ob: or adjacent bits
                <br/>
                <br/>swn: swap adjacent nibbles (half-bytes)
                <br/>xon: xor adjacent nibbles
                <br/>an: and adjacent nibbles
                <br/>on: or adjacent nibbles
                <br/>
                <br/>swy: swap adjacent bytes
                <br/>xoy: xor adjacent bytes
                <br/>ay: and adjacent bytes
                <br/>oy: or adjacent bytes
              </div>
              <div class="section submain">
                <div class="section subline">
                  <div class="btn box op xor" id="dip_xoCbtn" onclick="DIP.op('dip','xoC')">xoC</div>
                  <div class="btn box op and" id="dip_aCbtn" onclick="DIP.op('dip','aC')">aC</div>
                  <div class="btn box op or" id="dip_oCbtn" onclick="DIP.op('dip','oC')">oC</div>
                </div>
                <div class="section sub3 line nowrap">
                  C: <input class="inplong" id="dip_C" value="abcdef" placeholder="hex constant"></input>
                </div>
              </div>
              <div class="section sub">
                <div class="text addendum i">
                  xoC: xor with constant C (hex)
                  <br/>aC: and with constant C
                  <br/>oC: or with constant C
                  <br/>
<br/><div class="text icon actualsize">: 1 image pixel == 1 device pixel.</div>
                  <br/>Files open in browser (not uploaded).
                  <br/>Firefox/Chrome browsers tested.
                  <br/>Last updated March 2023 (version 0.81)
                </div>
              </div>
            </div>
          </div>
        </div>

      </div>

      <div class="section main foot">
        <div class="text foot">
          2023 Greg Sidal cc-by-nc
          <br/><div class="text">Self-contained downloadable (March 2023)</div>
          <div id="dip_canvasdata" class="section main noshow">
            <div class="btn box op" onclick="DIP.togglecanvasdata()">Toggle allow canvas data</div>
          </div>
        </div>
      </div>

    </div></div></div>

    <div id="dip_wait" class="cover">
      <div class="msg blink">
        w o r k i n g . . .
      </div>
    </div>

  </body>
</html>
